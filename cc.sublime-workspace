{
	"auto_complete":
	{
		"selected_items":
		[
			[
				"for",
				"for	for (…) {…}"
			]
		]
	},
	"buffers":
	[
		{
			"contents": "// Copyright 2012 Google Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n(function(global) {\n  'use strict';\n\n  // Detect and do basic sanity checking on Object/Array.observe.\n  function detectObjectObserve() {\n    if (typeof Object.observe !== 'function' ||\n        typeof Array.observe !== 'function') {\n      return false;\n    }\n\n    var records = [];\n\n    function callback(recs) {\n      records = recs;\n    }\n\n    var test = {};\n    var arr = [];\n    Object.observe(test, callback);\n    Array.observe(arr, callback);\n    test.id = 1;\n    test.id = 2;\n    delete test.id;\n    arr.push(1, 2);\n    arr.length = 0;\n\n    Object.deliverChangeRecords(callback);\n    if (records.length !== 5)\n      return false;\n\n    if (records[0].type != 'add' ||\n        records[1].type != 'update' ||\n        records[2].type != 'delete' ||\n        records[3].type != 'splice' ||\n        records[4].type != 'splice') {\n      return false;\n    }\n\n    Object.unobserve(test, callback);\n    Array.unobserve(arr, callback);\n\n    return true;\n  }\n\n  var hasObserve = detectObjectObserve();\n\n  function detectEval() {\n    // Don't test for eval if we're running in a Chrome App environment.\n    // We check for APIs set that only exist in a Chrome App context.\n    if (typeof chrome !== 'undefined' && chrome.app && chrome.app.runtime) {\n      return false;\n    }\n\n    // Firefox OS Apps do not allow eval. This feature detection is very hacky\n    // but even if some other platform adds support for this function this code\n    // will continue to work.\n    if (navigator.getDeviceStorage) {\n      return false;\n    }\n\n    try {\n      var f = new Function('', 'return true;');\n      return f();\n    } catch (ex) {\n      return false;\n    }\n  }\n\n  var hasEval = detectEval();\n\n  function isIndex(s) {\n    return +s === s >>> 0;\n  }\n\n  function toNumber(s) {\n    return +s;\n  }\n\n  function isObject(obj) {\n    return obj === Object(obj);\n  }\n\n  var numberIsNaN = global.Number.isNaN || function(value) {\n    return typeof value === 'number' && global.isNaN(value);\n  }\n\n  function areSameValue(left, right) {\n    if (left === right)\n      return left !== 0 || 1 / left === 1 / right;\n    if (numberIsNaN(left) && numberIsNaN(right))\n      return true;\n\n    return left !== left && right !== right;\n  }\n\n  var createObject = ('__proto__' in {}) ?\n    function(obj) { return obj; } :\n    function(obj) {\n      var proto = obj.__proto__;\n      if (!proto)\n        return obj;\n      var newObject = Object.create(proto);\n      Object.getOwnPropertyNames(obj).forEach(function(name) {\n        Object.defineProperty(newObject, name,\n                             Object.getOwnPropertyDescriptor(obj, name));\n      });\n      return newObject;\n    };\n\n  var identStart = '[\\$_a-zA-Z]';\n  var identPart = '[\\$_a-zA-Z0-9]';\n  var identRegExp = new RegExp('^' + identStart + '+' + identPart + '*' + '$');\n\n  function getPathCharType(char) {\n    if (char === undefined)\n      return 'eof';\n\n    var code = char.charCodeAt(0);\n\n    switch(code) {\n      case 0x5B: // [\n      case 0x5D: // ]\n      case 0x2E: // .\n      case 0x22: // \"\n      case 0x27: // '\n      case 0x30: // 0\n        return char;\n\n      case 0x5F: // _\n      case 0x24: // $\n        return 'ident';\n\n      case 0x20: // Space\n      case 0x09: // Tab\n      case 0x0A: // Newline\n      case 0x0D: // Return\n      case 0xA0:  // No-break space\n      case 0xFEFF:  // Byte Order Mark\n      case 0x2028:  // Line Separator\n      case 0x2029:  // Paragraph Separator\n        return 'ws';\n    }\n\n    // a-z, A-Z\n    if ((0x61 <= code && code <= 0x7A) || (0x41 <= code && code <= 0x5A))\n      return 'ident';\n\n    // 1-9\n    if (0x31 <= code && code <= 0x39)\n      return 'number';\n\n    return 'else';\n  }\n\n  var pathStateMachine = {\n    'beforePath': {\n      'ws': ['beforePath'],\n      'ident': ['inIdent', 'append'],\n      '[': ['beforeElement'],\n      'eof': ['afterPath']\n    },\n\n    'inPath': {\n      'ws': ['inPath'],\n      '.': ['beforeIdent'],\n      '[': ['beforeElement'],\n      'eof': ['afterPath']\n    },\n\n    'beforeIdent': {\n      'ws': ['beforeIdent'],\n      'ident': ['inIdent', 'append']\n    },\n\n    'inIdent': {\n      'ident': ['inIdent', 'append'],\n      '0': ['inIdent', 'append'],\n      'number': ['inIdent', 'append'],\n      'ws': ['inPath', 'push'],\n      '.': ['beforeIdent', 'push'],\n      '[': ['beforeElement', 'push'],\n      'eof': ['afterPath', 'push']\n    },\n\n    'beforeElement': {\n      'ws': ['beforeElement'],\n      '0': ['afterZero', 'append'],\n      'number': ['inIndex', 'append'],\n      \"'\": ['inSingleQuote', 'append', ''],\n      '\"': ['inDoubleQuote', 'append', '']\n    },\n\n    'afterZero': {\n      'ws': ['afterElement', 'push'],\n      ']': ['inPath', 'push']\n    },\n\n    'inIndex': {\n      '0': ['inIndex', 'append'],\n      'number': ['inIndex', 'append'],\n      'ws': ['afterElement'],\n      ']': ['inPath', 'push']\n    },\n\n    'inSingleQuote': {\n      \"'\": ['afterElement'],\n      'eof': ['error'],\n      'else': ['inSingleQuote', 'append']\n    },\n\n    'inDoubleQuote': {\n      '\"': ['afterElement'],\n      'eof': ['error'],\n      'else': ['inDoubleQuote', 'append']\n    },\n\n    'afterElement': {\n      'ws': ['afterElement'],\n      ']': ['inPath', 'push']\n    }\n  }\n\n  function noop() {}\n\n  function parsePath(path) {\n    var keys = [];\n    var index = -1;\n    var c, newChar, key, type, transition, action, typeMap, mode = 'beforePath';\n\n    var actions = {\n      push: function() {\n        if (key === undefined)\n          return;\n\n        keys.push(key);\n        key = undefined;\n      },\n\n      append: function() {\n        if (key === undefined)\n          key = newChar\n        else\n          key += newChar;\n      }\n    };\n\n    function maybeUnescapeQuote() {\n      if (index >= path.length)\n        return;\n\n      var nextChar = path[index + 1];\n      if ((mode == 'inSingleQuote' && nextChar == \"'\") ||\n          (mode == 'inDoubleQuote' && nextChar == '\"')) {\n        index++;\n        newChar = nextChar;\n        actions.append();\n        return true;\n      }\n    }\n\n    while (mode) {\n      index++;\n      c = path[index];\n\n      if (c == '\\\\' && maybeUnescapeQuote(mode))\n        continue;\n\n      type = getPathCharType(c);\n      typeMap = pathStateMachine[mode];\n      transition = typeMap[type] || typeMap['else'] || 'error';\n\n      if (transition == 'error')\n        return; // parse error;\n\n      mode = transition[0];\n      action = actions[transition[1]] || noop;\n      newChar = transition[2] === undefined ? c : transition[2];\n      action();\n\n      if (mode === 'afterPath') {\n        return keys;\n      }\n    }\n\n    return; // parse error\n  }\n\n  function isIdent(s) {\n    return identRegExp.test(s);\n  }\n\n  var constructorIsPrivate = {};\n\n  function Path(parts, privateToken) {\n    if (privateToken !== constructorIsPrivate)\n      throw Error('Use Path.get to retrieve path objects');\n\n    for (var i = 0; i < parts.length; i++) {\n      this.push(String(parts[i]));\n    }\n\n    if (hasEval && this.length) {\n      this.getValueFrom = this.compiledGetValueFromFn();\n    }\n  }\n\n  // TODO(rafaelw): Make simple LRU cache\n  var pathCache = {};\n\n  function getPath(pathString) {\n    if (pathString instanceof Path)\n      return pathString;\n\n    if (pathString == null || pathString.length == 0)\n      pathString = '';\n\n    if (typeof pathString != 'string') {\n      if (isIndex(pathString.length)) {\n        // Constructed with array-like (pre-parsed) keys\n        return new Path(pathString, constructorIsPrivate);\n      }\n\n      pathString = String(pathString);\n    }\n\n    var path = pathCache[pathString];\n    if (path)\n      return path;\n\n    var parts = parsePath(pathString);\n    if (!parts)\n      return invalidPath;\n\n    var path = new Path(parts, constructorIsPrivate);\n    pathCache[pathString] = path;\n    return path;\n  }\n\n  Path.get = getPath;\n\n  function formatAccessor(key) {\n    if (isIndex(key)) {\n      return '[' + key + ']';\n    } else {\n      return '[\"' + key.replace(/\"/g, '\\\\\"') + '\"]';\n    }\n  }\n\n  Path.prototype = createObject({\n    __proto__: [],\n    valid: true,\n\n    toString: function() {\n      var pathString = '';\n      for (var i = 0; i < this.length; i++) {\n        var key = this[i];\n        if (isIdent(key)) {\n          pathString += i ? '.' + key : key;\n        } else {\n          pathString += formatAccessor(key);\n        }\n      }\n\n      return pathString;\n    },\n\n    getValueFrom: function(obj, directObserver) {\n      for (var i = 0; i < this.length; i++) {\n        if (obj == null)\n          return;\n        obj = obj[this[i]];\n      }\n      return obj;\n    },\n\n    iterateObjects: function(obj, observe) {\n      for (var i = 0; i < this.length; i++) {\n        if (i)\n          obj = obj[this[i - 1]];\n        if (!isObject(obj))\n          return;\n        observe(obj, this[0]);\n      }\n    },\n\n    compiledGetValueFromFn: function() {\n      var str = '';\n      var pathString = 'obj';\n      str += 'if (obj != null';\n      var i = 0;\n      var key;\n      for (; i < (this.length - 1); i++) {\n        key = this[i];\n        pathString += isIdent(key) ? '.' + key : formatAccessor(key);\n        str += ' &&\\n     ' + pathString + ' != null';\n      }\n      str += ')\\n';\n\n      var key = this[i];\n      pathString += isIdent(key) ? '.' + key : formatAccessor(key);\n\n      str += '  return ' + pathString + ';\\nelse\\n  return undefined;';\n      return new Function('obj', str);\n    },\n\n    setValueFrom: function(obj, value) {\n      if (!this.length)\n        return false;\n\n      for (var i = 0; i < this.length - 1; i++) {\n        if (!isObject(obj))\n          return false;\n        obj = obj[this[i]];\n      }\n\n      if (!isObject(obj))\n        return false;\n\n      obj[this[i]] = value;\n      return true;\n    }\n  });\n\n  var invalidPath = new Path('', constructorIsPrivate);\n  invalidPath.valid = false;\n  invalidPath.getValueFrom = invalidPath.setValueFrom = function() {};\n\n  var MAX_DIRTY_CHECK_CYCLES = 1000;\n\n  function dirtyCheck(observer) {\n    var cycles = 0;\n    while (cycles < MAX_DIRTY_CHECK_CYCLES && observer.check_()) {\n      cycles++;\n    }\n    if (global.testingExposeCycleCount)\n      global.dirtyCheckCycleCount = cycles;\n\n    return cycles > 0;\n  }\n\n  function objectIsEmpty(object) {\n    for (var prop in object)\n      return false;\n    return true;\n  }\n\n  function diffIsEmpty(diff) {\n    return objectIsEmpty(diff.added) &&\n           objectIsEmpty(diff.removed) &&\n           objectIsEmpty(diff.changed);\n  }\n\n  function diffObjectFromOldObject(object, oldObject) {\n    var added = {};\n    var removed = {};\n    var changed = {};\n\n    for (var prop in oldObject) {\n      var newValue = object[prop];\n\n      if (newValue !== undefined && newValue === oldObject[prop])\n        continue;\n\n      if (!(prop in object)) {\n        removed[prop] = undefined;\n        continue;\n      }\n\n      if (newValue !== oldObject[prop])\n        changed[prop] = newValue;\n    }\n\n    for (var prop in object) {\n      if (prop in oldObject)\n        continue;\n\n      added[prop] = object[prop];\n    }\n\n    if (Array.isArray(object) && object.length !== oldObject.length)\n      changed.length = object.length;\n\n    return {\n      added: added,\n      removed: removed,\n      changed: changed\n    };\n  }\n\n  var eomTasks = [];\n  function runEOMTasks() {\n    if (!eomTasks.length)\n      return false;\n\n    for (var i = 0; i < eomTasks.length; i++) {\n      eomTasks[i]();\n    }\n    eomTasks.length = 0;\n    return true;\n  }\n\n  var runEOM = hasObserve ? (function(){\n    var eomObj = { pingPong: true };\n    var eomRunScheduled = false;\n\n    Object.observe(eomObj, function() {\n      runEOMTasks();\n      eomRunScheduled = false;\n    });\n\n    return function(fn) {\n      eomTasks.push(fn);\n      if (!eomRunScheduled) {\n        eomRunScheduled = true;\n        eomObj.pingPong = !eomObj.pingPong;\n      }\n    };\n  })() :\n  (function() {\n    return function(fn) {\n      eomTasks.push(fn);\n    };\n  })();\n\n  var observedObjectCache = [];\n\n  function newObservedObject() {\n    var observer;\n    var object;\n    var discardRecords = false;\n    var first = true;\n\n    function callback(records) {\n      if (observer && observer.state_ === OPENED && !discardRecords)\n        observer.check_(records);\n    }\n\n    return {\n      open: function(obs) {\n        if (observer)\n          throw Error('ObservedObject in use');\n\n        if (!first)\n          Object.deliverChangeRecords(callback);\n\n        observer = obs;\n        first = false;\n      },\n      observe: function(obj, arrayObserve) {\n        object = obj;\n        if (arrayObserve)\n          Array.observe(object, callback);\n        else\n          Object.observe(object, callback);\n      },\n      deliver: function(discard) {\n        discardRecords = discard;\n        Object.deliverChangeRecords(callback);\n        discardRecords = false;\n      },\n      close: function() {\n        observer = undefined;\n        Object.unobserve(object, callback);\n        observedObjectCache.push(this);\n      }\n    };\n  }\n\n  /*\n   * The observedSet abstraction is a perf optimization which reduces the total\n   * number of Object.observe observations of a set of objects. The idea is that\n   * groups of Observers will have some object dependencies in common and this\n   * observed set ensures that each object in the transitive closure of\n   * dependencies is only observed once. The observedSet acts as a write barrier\n   * such that whenever any change comes through, all Observers are checked for\n   * changed values.\n   *\n   * Note that this optimization is explicitly moving work from setup-time to\n   * change-time.\n   *\n   * TODO(rafaelw): Implement \"garbage collection\". In order to move work off\n   * the critical path, when Observers are closed, their observed objects are\n   * not Object.unobserve(d). As a result, it's possible that if the observedSet\n   * is kept open, but some Observers have been closed, it could cause \"leaks\"\n   * (prevent otherwise collectable objects from being collected). At some\n   * point, we should implement incremental \"gc\" which keeps a list of\n   * observedSets which may need clean-up and does small amounts of cleanup on a\n   * timeout until all is clean.\n   */\n\n  function getObservedObject(observer, object, arrayObserve) {\n    var dir = observedObjectCache.pop() || newObservedObject();\n    dir.open(observer);\n    dir.observe(object, arrayObserve);\n    return dir;\n  }\n\n  var observedSetCache = [];\n\n  function newObservedSet() {\n    var observerCount = 0;\n    var observers = [];\n    var objects = [];\n    var rootObj;\n    var rootObjProps;\n\n    function observe(obj, prop) {\n      if (!obj)\n        return;\n\n      if (obj === rootObj)\n        rootObjProps[prop] = true;\n\n      if (objects.indexOf(obj) < 0) {\n        objects.push(obj);\n        Object.observe(obj, callback);\n      }\n\n      observe(Object.getPrototypeOf(obj), prop);\n    }\n\n    function allRootObjNonObservedProps(recs) {\n      for (var i = 0; i < recs.length; i++) {\n        var rec = recs[i];\n        if (rec.object !== rootObj ||\n            rootObjProps[rec.name] ||\n            rec.type === 'setPrototype') {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    function callback(recs) {\n      if (allRootObjNonObservedProps(recs))\n        return;\n\n      var observer;\n      for (var i = 0; i < observers.length; i++) {\n        observer = observers[i];\n        if (observer.state_ == OPENED) {\n          observer.iterateObjects_(observe);\n        }\n      }\n\n      for (var i = 0; i < observers.length; i++) {\n        observer = observers[i];\n        if (observer.state_ == OPENED) {\n          observer.check_();\n        }\n      }\n    }\n\n    var record = {\n      object: undefined,\n      objects: objects,\n      open: function(obs, object) {\n        if (!rootObj) {\n          rootObj = object;\n          rootObjProps = {};\n        }\n\n        observers.push(obs);\n        observerCount++;\n        obs.iterateObjects_(observe);\n      },\n      close: function(obs) {\n        observerCount--;\n        if (observerCount > 0) {\n          return;\n        }\n\n        for (var i = 0; i < objects.length; i++) {\n          Object.unobserve(objects[i], callback);\n          Observer.unobservedCount++;\n        }\n\n        observers.length = 0;\n        objects.length = 0;\n        rootObj = undefined;\n        rootObjProps = undefined;\n        observedSetCache.push(this);\n      }\n    };\n\n    return record;\n  }\n\n  var lastObservedSet;\n\n  function getObservedSet(observer, obj) {\n    if (!lastObservedSet || lastObservedSet.object !== obj) {\n      lastObservedSet = observedSetCache.pop() || newObservedSet();\n      lastObservedSet.object = obj;\n    }\n    lastObservedSet.open(observer, obj);\n    return lastObservedSet;\n  }\n\n  var UNOPENED = 0;\n  var OPENED = 1;\n  var CLOSED = 2;\n  var RESETTING = 3;\n\n  var nextObserverId = 1;\n\n  function Observer() {\n    this.state_ = UNOPENED;\n    this.callback_ = undefined;\n    this.target_ = undefined; // TODO(rafaelw): Should be WeakRef\n    this.directObserver_ = undefined;\n    this.value_ = undefined;\n    this.id_ = nextObserverId++;\n  }\n\n  Observer.prototype = {\n    open: function(callback, target) {\n      if (this.state_ != UNOPENED)\n        throw Error('Observer has already been opened.');\n\n      addToAll(this);\n      this.callback_ = callback;\n      this.target_ = target;\n      this.connect_();\n      this.state_ = OPENED;\n      return this.value_;\n    },\n\n    close: function() {\n      if (this.state_ != OPENED)\n        return;\n\n      removeFromAll(this);\n      this.disconnect_();\n      this.value_ = undefined;\n      this.callback_ = undefined;\n      this.target_ = undefined;\n      this.state_ = CLOSED;\n    },\n\n    deliver: function() {\n      if (this.state_ != OPENED)\n        return;\n\n      dirtyCheck(this);\n    },\n\n    report_: function(changes) {\n      try {\n        this.callback_.apply(this.target_, changes);\n      } catch (ex) {\n        Observer._errorThrownDuringCallback = true;\n        console.error('Exception caught during observer callback: ' +\n                       (ex.stack || ex));\n      }\n    },\n\n    discardChanges: function() {\n      this.check_(undefined, true);\n      return this.value_;\n    }\n  }\n\n  var collectObservers = !hasObserve;\n  var allObservers;\n  Observer._allObserversCount = 0;\n\n  if (collectObservers) {\n    allObservers = [];\n  }\n\n  function addToAll(observer) {\n    Observer._allObserversCount++;\n    if (!collectObservers)\n      return;\n\n    allObservers.push(observer);\n  }\n\n  function removeFromAll(observer) {\n    Observer._allObserversCount--;\n  }\n\n  var runningMicrotaskCheckpoint = false;\n\n  var hasDebugForceFullDelivery = hasObserve && hasEval && (function() {\n    try {\n      eval('%RunMicrotasks()');\n      return true;\n    } catch (ex) {\n      return false;\n    }\n  })();\n\n  global.Platform = global.Platform || {};\n\n  global.Platform.performMicrotaskCheckpoint = function() {\n    if (runningMicrotaskCheckpoint)\n      return;\n\n    if (hasDebugForceFullDelivery) {\n      eval('%RunMicrotasks()');\n      return;\n    }\n\n    if (!collectObservers)\n      return;\n\n    runningMicrotaskCheckpoint = true;\n\n    var cycles = 0;\n    var anyChanged, toCheck;\n\n    do {\n      cycles++;\n      toCheck = allObservers;\n      allObservers = [];\n      anyChanged = false;\n\n      for (var i = 0; i < toCheck.length; i++) {\n        var observer = toCheck[i];\n        if (observer.state_ != OPENED)\n          continue;\n\n        if (observer.check_())\n          anyChanged = true;\n\n        allObservers.push(observer);\n      }\n      if (runEOMTasks())\n        anyChanged = true;\n    } while (cycles < MAX_DIRTY_CHECK_CYCLES && anyChanged);\n\n    if (global.testingExposeCycleCount)\n      global.dirtyCheckCycleCount = cycles;\n\n    runningMicrotaskCheckpoint = false;\n  };\n\n  if (collectObservers) {\n    global.Platform.clearObservers = function() {\n      allObservers = [];\n    };\n  }\n\n  function ObjectObserver(object) {\n    Observer.call(this);\n    this.value_ = object;\n    this.oldObject_ = undefined;\n  }\n\n  ObjectObserver.prototype = createObject({\n    __proto__: Observer.prototype,\n\n    arrayObserve: false,\n\n    connect_: function(callback, target) {\n      if (hasObserve) {\n        this.directObserver_ = getObservedObject(this, this.value_,\n                                                 this.arrayObserve);\n      } else {\n        this.oldObject_ = this.copyObject(this.value_);\n      }\n\n    },\n\n    copyObject: function(object) {\n      var copy = Array.isArray(object) ? [] : {};\n      for (var prop in object) {\n        copy[prop] = object[prop];\n      };\n      if (Array.isArray(object))\n        copy.length = object.length;\n      return copy;\n    },\n\n    check_: function(changeRecords, skipChanges) {\n      var diff;\n      var oldValues;\n      if (hasObserve) {\n        if (!changeRecords)\n          return false;\n\n        oldValues = {};\n        diff = diffObjectFromChangeRecords(this.value_, changeRecords,\n                                           oldValues);\n      } else {\n        oldValues = this.oldObject_;\n        diff = diffObjectFromOldObject(this.value_, this.oldObject_);\n      }\n\n      if (diffIsEmpty(diff))\n        return false;\n\n      if (!hasObserve)\n        this.oldObject_ = this.copyObject(this.value_);\n\n      this.report_([\n        diff.added || {},\n        diff.removed || {},\n        diff.changed || {},\n        function(property) {\n          return oldValues[property];\n        }\n      ]);\n\n      return true;\n    },\n\n    disconnect_: function() {\n      if (hasObserve) {\n        this.directObserver_.close();\n        this.directObserver_ = undefined;\n      } else {\n        this.oldObject_ = undefined;\n      }\n    },\n\n    deliver: function() {\n      if (this.state_ != OPENED)\n        return;\n\n      if (hasObserve)\n        this.directObserver_.deliver(false);\n      else\n        dirtyCheck(this);\n    },\n\n    discardChanges: function() {\n      if (this.directObserver_)\n        this.directObserver_.deliver(true);\n      else\n        this.oldObject_ = this.copyObject(this.value_);\n\n      return this.value_;\n    }\n  });\n\n  function ArrayObserver(array) {\n    if (!Array.isArray(array))\n      throw Error('Provided object is not an Array');\n    ObjectObserver.call(this, array);\n  }\n\n  ArrayObserver.prototype = createObject({\n\n    __proto__: ObjectObserver.prototype,\n\n    arrayObserve: true,\n\n    copyObject: function(arr) {\n      return arr.slice();\n    },\n\n    check_: function(changeRecords) {\n      var splices;\n      if (hasObserve) {\n        if (!changeRecords)\n          return false;\n        splices = projectArraySplices(this.value_, changeRecords);\n      } else {\n        splices = calcSplices(this.value_, 0, this.value_.length,\n                              this.oldObject_, 0, this.oldObject_.length);\n      }\n\n      if (!splices || !splices.length)\n        return false;\n\n      if (!hasObserve)\n        this.oldObject_ = this.copyObject(this.value_);\n\n      this.report_([splices]);\n      return true;\n    }\n  });\n\n  ArrayObserver.applySplices = function(previous, current, splices) {\n    splices.forEach(function(splice) {\n      var spliceArgs = [splice.index, splice.removed.length];\n      var addIndex = splice.index;\n      while (addIndex < splice.index + splice.addedCount) {\n        spliceArgs.push(current[addIndex]);\n        addIndex++;\n      }\n\n      Array.prototype.splice.apply(previous, spliceArgs);\n    });\n  };\n\n  function PathObserver(object, path) {\n    Observer.call(this);\n\n    this.object_ = object;\n    this.path_ = getPath(path);\n    this.directObserver_ = undefined;\n  }\n\n  PathObserver.prototype = createObject({\n    __proto__: Observer.prototype,\n\n    get path() {\n      return this.path_;\n    },\n\n    connect_: function() {\n      if (hasObserve)\n        this.directObserver_ = getObservedSet(this, this.object_);\n\n      this.check_(undefined, true);\n    },\n\n    disconnect_: function() {\n      this.value_ = undefined;\n\n      if (this.directObserver_) {\n        this.directObserver_.close(this);\n        this.directObserver_ = undefined;\n      }\n    },\n\n    iterateObjects_: function(observe) {\n      this.path_.iterateObjects(this.object_, observe);\n    },\n\n    check_: function(changeRecords, skipChanges) {\n      var oldValue = this.value_;\n      this.value_ = this.path_.getValueFrom(this.object_);\n      if (skipChanges || areSameValue(this.value_, oldValue))\n        return false;\n\n      this.report_([this.value_, oldValue, this]);\n      return true;\n    },\n\n    setValue: function(newValue) {\n      if (this.path_)\n        this.path_.setValueFrom(this.object_, newValue);\n    }\n  });\n\n  function CompoundObserver(reportChangesOnOpen) {\n    Observer.call(this);\n\n    this.reportChangesOnOpen_ = reportChangesOnOpen;\n    this.value_ = [];\n    this.directObserver_ = undefined;\n    this.observed_ = [];\n  }\n\n  var observerSentinel = {};\n\n  CompoundObserver.prototype = createObject({\n    __proto__: Observer.prototype,\n\n    connect_: function() {\n      if (hasObserve) {\n        var object;\n        var needsDirectObserver = false;\n        for (var i = 0; i < this.observed_.length; i += 2) {\n          object = this.observed_[i]\n          if (object !== observerSentinel) {\n            needsDirectObserver = true;\n            break;\n          }\n        }\n\n        if (needsDirectObserver)\n          this.directObserver_ = getObservedSet(this, object);\n      }\n\n      this.check_(undefined, !this.reportChangesOnOpen_);\n    },\n\n    disconnect_: function() {\n      for (var i = 0; i < this.observed_.length; i += 2) {\n        if (this.observed_[i] === observerSentinel)\n          this.observed_[i + 1].close();\n      }\n      this.observed_.length = 0;\n      this.value_.length = 0;\n\n      if (this.directObserver_) {\n        this.directObserver_.close(this);\n        this.directObserver_ = undefined;\n      }\n    },\n\n    addPath: function(object, path) {\n      if (this.state_ != UNOPENED && this.state_ != RESETTING)\n        throw Error('Cannot add paths once started.');\n\n      var path = getPath(path);\n      this.observed_.push(object, path);\n      if (!this.reportChangesOnOpen_)\n        return;\n      var index = this.observed_.length / 2 - 1;\n      this.value_[index] = path.getValueFrom(object);\n    },\n\n    addObserver: function(observer) {\n      if (this.state_ != UNOPENED && this.state_ != RESETTING)\n        throw Error('Cannot add observers once started.');\n\n      this.observed_.push(observerSentinel, observer);\n      if (!this.reportChangesOnOpen_)\n        return;\n      var index = this.observed_.length / 2 - 1;\n      this.value_[index] = observer.open(this.deliver, this);\n    },\n\n    startReset: function() {\n      if (this.state_ != OPENED)\n        throw Error('Can only reset while open');\n\n      this.state_ = RESETTING;\n      this.disconnect_();\n    },\n\n    finishReset: function() {\n      if (this.state_ != RESETTING)\n        throw Error('Can only finishReset after startReset');\n      this.state_ = OPENED;\n      this.connect_();\n\n      return this.value_;\n    },\n\n    iterateObjects_: function(observe) {\n      var object;\n      for (var i = 0; i < this.observed_.length; i += 2) {\n        object = this.observed_[i]\n        if (object !== observerSentinel)\n          this.observed_[i + 1].iterateObjects(object, observe)\n      }\n    },\n\n    check_: function(changeRecords, skipChanges) {\n      var oldValues;\n      for (var i = 0; i < this.observed_.length; i += 2) {\n        var object = this.observed_[i];\n        var path = this.observed_[i+1];\n        var value;\n        if (object === observerSentinel) {\n          var observable = path;\n          value = this.state_ === UNOPENED ?\n              observable.open(this.deliver, this) :\n              observable.discardChanges();\n        } else {\n          value = path.getValueFrom(object);\n        }\n\n        if (skipChanges) {\n          this.value_[i / 2] = value;\n          continue;\n        }\n\n        if (areSameValue(value, this.value_[i / 2]))\n          continue;\n\n        oldValues = oldValues || [];\n        oldValues[i / 2] = this.value_[i / 2];\n        this.value_[i / 2] = value;\n      }\n\n      if (!oldValues)\n        return false;\n\n      // TODO(rafaelw): Having observed_ as the third callback arg here is\n      // pretty lame API. Fix.\n      this.report_([this.value_, oldValues, this.observed_]);\n      return true;\n    }\n  });\n\n  function identFn(value) { return value; }\n\n  function ObserverTransform(observable, getValueFn, setValueFn,\n                             dontPassThroughSet) {\n    this.callback_ = undefined;\n    this.target_ = undefined;\n    this.value_ = undefined;\n    this.observable_ = observable;\n    this.getValueFn_ = getValueFn || identFn;\n    this.setValueFn_ = setValueFn || identFn;\n    // TODO(rafaelw): This is a temporary hack. PolymerExpressions needs this\n    // at the moment because of a bug in it's dependency tracking.\n    this.dontPassThroughSet_ = dontPassThroughSet;\n  }\n\n  ObserverTransform.prototype = {\n    open: function(callback, target) {\n      this.callback_ = callback;\n      this.target_ = target;\n      this.value_ =\n          this.getValueFn_(this.observable_.open(this.observedCallback_, this));\n      return this.value_;\n    },\n\n    observedCallback_: function(value) {\n      value = this.getValueFn_(value);\n      if (areSameValue(value, this.value_))\n        return;\n      var oldValue = this.value_;\n      this.value_ = value;\n      this.callback_.call(this.target_, this.value_, oldValue);\n    },\n\n    discardChanges: function() {\n      this.value_ = this.getValueFn_(this.observable_.discardChanges());\n      return this.value_;\n    },\n\n    deliver: function() {\n      return this.observable_.deliver();\n    },\n\n    setValue: function(value) {\n      value = this.setValueFn_(value);\n      if (!this.dontPassThroughSet_ && this.observable_.setValue)\n        return this.observable_.setValue(value);\n    },\n\n    close: function() {\n      if (this.observable_)\n        this.observable_.close();\n      this.callback_ = undefined;\n      this.target_ = undefined;\n      this.observable_ = undefined;\n      this.value_ = undefined;\n      this.getValueFn_ = undefined;\n      this.setValueFn_ = undefined;\n    }\n  }\n\n  var expectedRecordTypes = {\n    add: true,\n    update: true,\n    delete: true\n  };\n\n  function diffObjectFromChangeRecords(object, changeRecords, oldValues) {\n    var added = {};\n    var removed = {};\n\n    for (var i = 0; i < changeRecords.length; i++) {\n      var record = changeRecords[i];\n      if (!expectedRecordTypes[record.type]) {\n        console.error('Unknown changeRecord type: ' + record.type);\n        console.error(record);\n        continue;\n      }\n\n      if (!(record.name in oldValues))\n        oldValues[record.name] = record.oldValue;\n\n      if (record.type == 'update')\n        continue;\n\n      if (record.type == 'add') {\n        if (record.name in removed)\n          delete removed[record.name];\n        else\n          added[record.name] = true;\n\n        continue;\n      }\n\n      // type = 'delete'\n      if (record.name in added) {\n        delete added[record.name];\n        delete oldValues[record.name];\n      } else {\n        removed[record.name] = true;\n      }\n    }\n\n    for (var prop in added)\n      added[prop] = object[prop];\n\n    for (var prop in removed)\n      removed[prop] = undefined;\n\n    var changed = {};\n    for (var prop in oldValues) {\n      if (prop in added || prop in removed)\n        continue;\n\n      var newValue = object[prop];\n      if (oldValues[prop] !== newValue)\n        changed[prop] = newValue;\n    }\n\n    return {\n      added: added,\n      removed: removed,\n      changed: changed\n    };\n  }\n\n  function newSplice(index, removed, addedCount) {\n    return {\n      index: index,\n      removed: removed,\n      addedCount: addedCount\n    };\n  }\n\n  var EDIT_LEAVE = 0;\n  var EDIT_UPDATE = 1;\n  var EDIT_ADD = 2;\n  var EDIT_DELETE = 3;\n\n  function ArraySplice() {}\n\n  ArraySplice.prototype = {\n\n    // Note: This function is *based* on the computation of the Levenshtein\n    // \"edit\" distance. The one change is that \"updates\" are treated as two\n    // edits - not one. With Array splices, an update is really a delete\n    // followed by an add. By retaining this, we optimize for \"keeping\" the\n    // maximum array items in the original array. For example:\n    //\n    //   'xxxx123' -> '123yyyy'\n    //\n    // With 1-edit updates, the shortest path would be just to update all seven\n    // characters. With 2-edit updates, we delete 4, leave 3, and add 4. This\n    // leaves the substring '123' intact.\n    calcEditDistances: function(current, currentStart, currentEnd,\n                                old, oldStart, oldEnd) {\n      // \"Deletion\" columns\n      var rowCount = oldEnd - oldStart + 1;\n      var columnCount = currentEnd - currentStart + 1;\n      var distances = new Array(rowCount);\n\n      // \"Addition\" rows. Initialize null column.\n      for (var i = 0; i < rowCount; i++) {\n        distances[i] = new Array(columnCount);\n        distances[i][0] = i;\n      }\n\n      // Initialize null row\n      for (var j = 0; j < columnCount; j++)\n        distances[0][j] = j;\n\n      for (var i = 1; i < rowCount; i++) {\n        for (var j = 1; j < columnCount; j++) {\n          if (this.equals(current[currentStart + j - 1], old[oldStart + i - 1]))\n            distances[i][j] = distances[i - 1][j - 1];\n          else {\n            var north = distances[i - 1][j] + 1;\n            var west = distances[i][j - 1] + 1;\n            distances[i][j] = north < west ? north : west;\n          }\n        }\n      }\n\n      return distances;\n    },\n\n    // This starts at the final weight, and walks \"backward\" by finding\n    // the minimum previous weight recursively until the origin of the weight\n    // matrix.\n    spliceOperationsFromEditDistances: function(distances) {\n      var i = distances.length - 1;\n      var j = distances[0].length - 1;\n      var current = distances[i][j];\n      var edits = [];\n      while (i > 0 || j > 0) {\n        if (i == 0) {\n          edits.push(EDIT_ADD);\n          j--;\n          continue;\n        }\n        if (j == 0) {\n          edits.push(EDIT_DELETE);\n          i--;\n          continue;\n        }\n        var northWest = distances[i - 1][j - 1];\n        var west = distances[i - 1][j];\n        var north = distances[i][j - 1];\n\n        var min;\n        if (west < north)\n          min = west < northWest ? west : northWest;\n        else\n          min = north < northWest ? north : northWest;\n\n        if (min == northWest) {\n          if (northWest == current) {\n            edits.push(EDIT_LEAVE);\n          } else {\n            edits.push(EDIT_UPDATE);\n            current = northWest;\n          }\n          i--;\n          j--;\n        } else if (min == west) {\n          edits.push(EDIT_DELETE);\n          i--;\n          current = west;\n        } else {\n          edits.push(EDIT_ADD);\n          j--;\n          current = north;\n        }\n      }\n\n      edits.reverse();\n      return edits;\n    },\n\n    /**\n     * Splice Projection functions:\n     *\n     * A splice map is a representation of how a previous array of items\n     * was transformed into a new array of items. Conceptually it is a list of\n     * tuples of\n     *\n     *   <index, removed, addedCount>\n     *\n     * which are kept in ascending index order of. The tuple represents that at\n     * the |index|, |removed| sequence of items were removed, and counting forward\n     * from |index|, |addedCount| items were added.\n     */\n\n    /**\n     * Lacking individual splice mutation information, the minimal set of\n     * splices can be synthesized given the previous state and final state of an\n     * array. The basic approach is to calculate the edit distance matrix and\n     * choose the shortest path through it.\n     *\n     * Complexity: O(l * p)\n     *   l: The length of the current array\n     *   p: The length of the old array\n     */\n    calcSplices: function(current, currentStart, currentEnd,\n                          old, oldStart, oldEnd) {\n      var prefixCount = 0;\n      var suffixCount = 0;\n\n      var minLength = Math.min(currentEnd - currentStart, oldEnd - oldStart);\n      if (currentStart == 0 && oldStart == 0)\n        prefixCount = this.sharedPrefix(current, old, minLength);\n\n      if (currentEnd == current.length && oldEnd == old.length)\n        suffixCount = this.sharedSuffix(current, old, minLength - prefixCount);\n\n      currentStart += prefixCount;\n      oldStart += prefixCount;\n      currentEnd -= suffixCount;\n      oldEnd -= suffixCount;\n\n      if (currentEnd - currentStart == 0 && oldEnd - oldStart == 0)\n        return [];\n\n      if (currentStart == currentEnd) {\n        var splice = newSplice(currentStart, [], 0);\n        while (oldStart < oldEnd)\n          splice.removed.push(old[oldStart++]);\n\n        return [ splice ];\n      } else if (oldStart == oldEnd)\n        return [ newSplice(currentStart, [], currentEnd - currentStart) ];\n\n      var ops = this.spliceOperationsFromEditDistances(\n          this.calcEditDistances(current, currentStart, currentEnd,\n                                 old, oldStart, oldEnd));\n\n      var splice = undefined;\n      var splices = [];\n      var index = currentStart;\n      var oldIndex = oldStart;\n      for (var i = 0; i < ops.length; i++) {\n        switch(ops[i]) {\n          case EDIT_LEAVE:\n            if (splice) {\n              splices.push(splice);\n              splice = undefined;\n            }\n\n            index++;\n            oldIndex++;\n            break;\n          case EDIT_UPDATE:\n            if (!splice)\n              splice = newSplice(index, [], 0);\n\n            splice.addedCount++;\n            index++;\n\n            splice.removed.push(old[oldIndex]);\n            oldIndex++;\n            break;\n          case EDIT_ADD:\n            if (!splice)\n              splice = newSplice(index, [], 0);\n\n            splice.addedCount++;\n            index++;\n            break;\n          case EDIT_DELETE:\n            if (!splice)\n              splice = newSplice(index, [], 0);\n\n            splice.removed.push(old[oldIndex]);\n            oldIndex++;\n            break;\n        }\n      }\n\n      if (splice) {\n        splices.push(splice);\n      }\n      return splices;\n    },\n\n    sharedPrefix: function(current, old, searchLength) {\n      for (var i = 0; i < searchLength; i++)\n        if (!this.equals(current[i], old[i]))\n          return i;\n      return searchLength;\n    },\n\n    sharedSuffix: function(current, old, searchLength) {\n      var index1 = current.length;\n      var index2 = old.length;\n      var count = 0;\n      while (count < searchLength && this.equals(current[--index1], old[--index2]))\n        count++;\n\n      return count;\n    },\n\n    calculateSplices: function(current, previous) {\n      return this.calcSplices(current, 0, current.length, previous, 0,\n                              previous.length);\n    },\n\n    equals: function(currentValue, previousValue) {\n      return currentValue === previousValue;\n    }\n  };\n\n  var arraySplice = new ArraySplice();\n\n  function calcSplices(current, currentStart, currentEnd,\n                       old, oldStart, oldEnd) {\n    return arraySplice.calcSplices(current, currentStart, currentEnd,\n                                   old, oldStart, oldEnd);\n  }\n\n  function intersect(start1, end1, start2, end2) {\n    // Disjoint\n    if (end1 < start2 || end2 < start1)\n      return -1;\n\n    // Adjacent\n    if (end1 == start2 || end2 == start1)\n      return 0;\n\n    // Non-zero intersect, span1 first\n    if (start1 < start2) {\n      if (end1 < end2)\n        return end1 - start2; // Overlap\n      else\n        return end2 - start2; // Contained\n    } else {\n      // Non-zero intersect, span2 first\n      if (end2 < end1)\n        return end2 - start1; // Overlap\n      else\n        return end1 - start1; // Contained\n    }\n  }\n\n  function mergeSplice(splices, index, removed, addedCount) {\n\n    var splice = newSplice(index, removed, addedCount);\n\n    var inserted = false;\n    var insertionOffset = 0;\n\n    for (var i = 0; i < splices.length; i++) {\n      var current = splices[i];\n      current.index += insertionOffset;\n\n      if (inserted)\n        continue;\n\n      var intersectCount = intersect(splice.index,\n                                     splice.index + splice.removed.length,\n                                     current.index,\n                                     current.index + current.addedCount);\n\n      if (intersectCount >= 0) {\n        // Merge the two splices\n\n        splices.splice(i, 1);\n        i--;\n\n        insertionOffset -= current.addedCount - current.removed.length;\n\n        splice.addedCount += current.addedCount - intersectCount;\n        var deleteCount = splice.removed.length +\n                          current.removed.length - intersectCount;\n\n        if (!splice.addedCount && !deleteCount) {\n          // merged splice is a noop. discard.\n          inserted = true;\n        } else {\n          var removed = current.removed;\n\n          if (splice.index < current.index) {\n            // some prefix of splice.removed is prepended to current.removed.\n            var prepend = splice.removed.slice(0, current.index - splice.index);\n            Array.prototype.push.apply(prepend, removed);\n            removed = prepend;\n          }\n\n          if (splice.index + splice.removed.length > current.index + current.addedCount) {\n            // some suffix of splice.removed is appended to current.removed.\n            var append = splice.removed.slice(current.index + current.addedCount - splice.index);\n            Array.prototype.push.apply(removed, append);\n          }\n\n          splice.removed = removed;\n          if (current.index < splice.index) {\n            splice.index = current.index;\n          }\n        }\n      } else if (splice.index < current.index) {\n        // Insert splice here.\n\n        inserted = true;\n\n        splices.splice(i, 0, splice);\n        i++;\n\n        var offset = splice.addedCount - splice.removed.length\n        current.index += offset;\n        insertionOffset += offset;\n      }\n    }\n\n    if (!inserted)\n      splices.push(splice);\n  }\n\n  function createInitialSplices(array, changeRecords) {\n    var splices = [];\n\n    for (var i = 0; i < changeRecords.length; i++) {\n      var record = changeRecords[i];\n      switch(record.type) {\n        case 'splice':\n          mergeSplice(splices, record.index, record.removed.slice(), record.addedCount);\n          break;\n        case 'add':\n        case 'update':\n        case 'delete':\n          if (!isIndex(record.name))\n            continue;\n          var index = toNumber(record.name);\n          if (index < 0)\n            continue;\n          mergeSplice(splices, index, [record.oldValue], 1);\n          break;\n        default:\n          console.error('Unexpected record type: ' + JSON.stringify(record));\n          break;\n      }\n    }\n\n    return splices;\n  }\n\n  function projectArraySplices(array, changeRecords) {\n    var splices = [];\n\n    createInitialSplices(array, changeRecords).forEach(function(splice) {\n      if (splice.addedCount == 1 && splice.removed.length == 1) {\n        if (splice.removed[0] !== array[splice.index])\n          splices.push(splice);\n\n        return\n      };\n\n      splices = splices.concat(calcSplices(array, splice.index, splice.index + splice.addedCount,\n                                           splice.removed, 0, splice.removed.length));\n    });\n\n    return splices;\n  }\n\n  global.Observer = Observer;\n  global.Observer.runEOM_ = runEOM;\n  global.Observer.observerSentinel_ = observerSentinel; // for testing.\n  global.Observer.hasObjectObserve = hasObserve;\n  global.ArrayObserver = ArrayObserver;\n  global.ArrayObserver.calculateSplices = function(current, previous) {\n    return arraySplice.calculateSplices(current, previous);\n  };\n\n  global.ArraySplice = ArraySplice;\n  global.ObjectObserver = ObjectObserver;\n  global.PathObserver = PathObserver;\n  global.CompoundObserver = CompoundObserver;\n  global.Path = Path;\n  global.ObserverTransform = ObserverTransform;\n})(typeof global !== 'undefined' && global && typeof module !== 'undefined' && module ? global : this || window);\n\n// Copyright (c) 2014 The Polymer Project Authors. All rights reserved.\n// This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n// The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n// The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n// Code distributed by Google as part of the polymer project is also\n// subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\n(function(global) {\n  'use strict';\n\n  var filter = Array.prototype.filter.call.bind(Array.prototype.filter);\n\n  function getTreeScope(node) {\n    while (node.parentNode) {\n      node = node.parentNode;\n    }\n\n    return typeof node.getElementById === 'function' ? node : null;\n  }\n\n  Node.prototype.bind = function(name, observable) {\n    console.error('Unhandled binding to Node: ', this, name, observable);\n  };\n\n  Node.prototype.bindFinished = function() {};\n\n  function updateBindings(node, name, binding) {\n    var bindings = node.bindings_;\n    if (!bindings)\n      bindings = node.bindings_ = {};\n\n    if (bindings[name])\n      binding[name].close();\n\n    return bindings[name] = binding;\n  }\n\n  function returnBinding(node, name, binding) {\n    return binding;\n  }\n\n  function sanitizeValue(value) {\n    return value == null ? '' : value;\n  }\n\n  function updateText(node, value) {\n    node.data = sanitizeValue(value);\n  }\n\n  function textBinding(node) {\n    return function(value) {\n      return updateText(node, value);\n    };\n  }\n\n  var maybeUpdateBindings = returnBinding;\n\n  Object.defineProperty(Platform, 'enableBindingsReflection', {\n    get: function() {\n      return maybeUpdateBindings === updateBindings;\n    },\n    set: function(enable) {\n      maybeUpdateBindings = enable ? updateBindings : returnBinding;\n      return enable;\n    },\n    configurable: true\n  });\n\n  Text.prototype.bind = function(name, value, oneTime) {\n    if (name !== 'textContent')\n      return Node.prototype.bind.call(this, name, value, oneTime);\n\n    if (oneTime)\n      return updateText(this, value);\n\n    var observable = value;\n    updateText(this, observable.open(textBinding(this)));\n    return maybeUpdateBindings(this, name, observable);\n  }\n\n  function updateAttribute(el, name, conditional, value) {\n    if (conditional) {\n      if (value)\n        el.setAttribute(name, '');\n      else\n        el.removeAttribute(name);\n      return;\n    }\n\n    el.setAttribute(name, sanitizeValue(value));\n  }\n\n  function attributeBinding(el, name, conditional) {\n    return function(value) {\n      updateAttribute(el, name, conditional, value);\n    };\n  }\n\n  Element.prototype.bind = function(name, value, oneTime) {\n    var conditional = name[name.length - 1] == '?';\n    if (conditional) {\n      this.removeAttribute(name);\n      name = name.slice(0, -1);\n    }\n\n    if (oneTime)\n      return updateAttribute(this, name, conditional, value);\n\n\n    var observable = value;\n    updateAttribute(this, name, conditional,\n        observable.open(attributeBinding(this, name, conditional)));\n\n    return maybeUpdateBindings(this, name, observable);\n  };\n\n  var checkboxEventType;\n  (function() {\n    // Attempt to feature-detect which event (change or click) is fired first\n    // for checkboxes.\n    var div = document.createElement('div');\n    var checkbox = div.appendChild(document.createElement('input'));\n    checkbox.setAttribute('type', 'checkbox');\n    var first;\n    var count = 0;\n    checkbox.addEventListener('click', function(e) {\n      count++;\n      first = first || 'click';\n    });\n    checkbox.addEventListener('change', function() {\n      count++;\n      first = first || 'change';\n    });\n\n    var event = document.createEvent('MouseEvent');\n    event.initMouseEvent(\"click\", true, true, window, 0, 0, 0, 0, 0, false,\n        false, false, false, 0, null);\n    checkbox.dispatchEvent(event);\n    // WebKit/Blink don't fire the change event if the element is outside the\n    // document, so assume 'change' for that case.\n    checkboxEventType = count == 1 ? 'change' : first;\n  })();\n\n  function getEventForInputType(element) {\n    switch (element.type) {\n      case 'checkbox':\n        return checkboxEventType;\n      case 'radio':\n      case 'select-multiple':\n      case 'select-one':\n        return 'change';\n      case 'range':\n        if (/Trident|MSIE/.test(navigator.userAgent))\n          return 'change';\n      default:\n        return 'input';\n    }\n  }\n\n  function updateInput(input, property, value, santizeFn) {\n    input[property] = (santizeFn || sanitizeValue)(value);\n  }\n\n  function inputBinding(input, property, santizeFn) {\n    return function(value) {\n      return updateInput(input, property, value, santizeFn);\n    }\n  }\n\n  function noop() {}\n\n  function bindInputEvent(input, property, observable, postEventFn) {\n    var eventType = getEventForInputType(input);\n\n    function eventHandler() {\n      observable.setValue(input[property]);\n      observable.discardChanges();\n      (postEventFn || noop)(input);\n      Platform.performMicrotaskCheckpoint();\n    }\n    input.addEventListener(eventType, eventHandler);\n\n    return {\n      close: function() {\n        input.removeEventListener(eventType, eventHandler);\n        observable.close();\n      },\n\n      observable_: observable\n    }\n  }\n\n  function booleanSanitize(value) {\n    return Boolean(value);\n  }\n\n  // |element| is assumed to be an HTMLInputElement with |type| == 'radio'.\n  // Returns an array containing all radio buttons other than |element| that\n  // have the same |name|, either in the form that |element| belongs to or,\n  // if no form, in the document tree to which |element| belongs.\n  //\n  // This implementation is based upon the HTML spec definition of a\n  // \"radio button group\":\n  //   http://www.whatwg.org/specs/web-apps/current-work/multipage/number-state.html#radio-button-group\n  //\n  function getAssociatedRadioButtons(element) {\n    if (element.form) {\n      return filter(element.form.elements, function(el) {\n        return el != element &&\n            el.tagName == 'INPUT' &&\n            el.type == 'radio' &&\n            el.name == element.name;\n      });\n    } else {\n      var treeScope = getTreeScope(element);\n      if (!treeScope)\n        return [];\n      var radios = treeScope.querySelectorAll(\n          'input[type=\"radio\"][name=\"' + element.name + '\"]');\n      return filter(radios, function(el) {\n        return el != element && !el.form;\n      });\n    }\n  }\n\n  function checkedPostEvent(input) {\n    // Only the radio button that is getting checked gets an event. We\n    // therefore find all the associated radio buttons and update their\n    // check binding manually.\n    if (input.tagName === 'INPUT' &&\n        input.type === 'radio') {\n      getAssociatedRadioButtons(input).forEach(function(radio) {\n        var checkedBinding = radio.bindings_.checked;\n        if (checkedBinding) {\n          // Set the value directly to avoid an infinite call stack.\n          checkedBinding.observable_.setValue(false);\n        }\n      });\n    }\n  }\n\n  HTMLInputElement.prototype.bind = function(name, value, oneTime) {\n    if (name !== 'value' && name !== 'checked')\n      return HTMLElement.prototype.bind.call(this, name, value, oneTime);\n\n    this.removeAttribute(name);\n    var sanitizeFn = name == 'checked' ? booleanSanitize : sanitizeValue;\n    var postEventFn = name == 'checked' ? checkedPostEvent : noop;\n\n    if (oneTime)\n      return updateInput(this, name, value, sanitizeFn);\n\n\n    var observable = value;\n    var binding = bindInputEvent(this, name, observable, postEventFn);\n    updateInput(this, name,\n                observable.open(inputBinding(this, name, sanitizeFn)),\n                sanitizeFn);\n\n    // Checkboxes may need to update bindings of other checkboxes.\n    return updateBindings(this, name, binding);\n  }\n\n  HTMLTextAreaElement.prototype.bind = function(name, value, oneTime) {\n    if (name !== 'value')\n      return HTMLElement.prototype.bind.call(this, name, value, oneTime);\n\n    this.removeAttribute('value');\n\n    if (oneTime)\n      return updateInput(this, 'value', value);\n\n    var observable = value;\n    var binding = bindInputEvent(this, 'value', observable);\n    updateInput(this, 'value',\n                observable.open(inputBinding(this, 'value', sanitizeValue)));\n    return maybeUpdateBindings(this, name, binding);\n  }\n\n  function updateOption(option, value) {\n    var parentNode = option.parentNode;;\n    var select;\n    var selectBinding;\n    var oldValue;\n    if (parentNode instanceof HTMLSelectElement &&\n        parentNode.bindings_ &&\n        parentNode.bindings_.value) {\n      select = parentNode;\n      selectBinding = select.bindings_.value;\n      oldValue = select.value;\n    }\n\n    option.value = sanitizeValue(value);\n\n    if (select && select.value != oldValue) {\n      selectBinding.observable_.setValue(select.value);\n      selectBinding.observable_.discardChanges();\n      Platform.performMicrotaskCheckpoint();\n    }\n  }\n\n  function optionBinding(option) {\n    return function(value) {\n      updateOption(option, value);\n    }\n  }\n\n  HTMLOptionElement.prototype.bind = function(name, value, oneTime) {\n    if (name !== 'value')\n      return HTMLElement.prototype.bind.call(this, name, value, oneTime);\n\n    this.removeAttribute('value');\n\n    if (oneTime)\n      return updateOption(this, value);\n\n    var observable = value;\n    var binding = bindInputEvent(this, 'value', observable);\n    updateOption(this, observable.open(optionBinding(this)));\n    return maybeUpdateBindings(this, name, binding);\n  }\n\n  HTMLSelectElement.prototype.bind = function(name, value, oneTime) {\n    if (name === 'selectedindex')\n      name = 'selectedIndex';\n\n    if (name !== 'selectedIndex' && name !== 'value')\n      return HTMLElement.prototype.bind.call(this, name, value, oneTime);\n\n    this.removeAttribute(name);\n\n    if (oneTime)\n      return updateInput(this, name, value);\n\n    var observable = value;\n    var binding = bindInputEvent(this, name, observable);\n    updateInput(this, name,\n                observable.open(inputBinding(this, name)));\n\n    // Option update events may need to access select bindings.\n    return updateBindings(this, name, binding);\n  }\n})(this);\n\n// Copyright (c) 2014 The Polymer Project Authors. All rights reserved.\n// This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n// The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n// The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n// Code distributed by Google as part of the polymer project is also\n// subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\n(function(global) {\n  'use strict';\n\n  function assert(v) {\n    if (!v)\n      throw new Error('Assertion failed');\n  }\n\n  var forEach = Array.prototype.forEach.call.bind(Array.prototype.forEach);\n\n  function getFragmentRoot(node) {\n    var p;\n    while (p = node.parentNode) {\n      node = p;\n    }\n\n    return node;\n  }\n\n  function searchRefId(node, id) {\n    if (!id)\n      return;\n\n    var ref;\n    var selector = '#' + id;\n    while (!ref) {\n      node = getFragmentRoot(node);\n\n      if (node.protoContent_)\n        ref = node.protoContent_.querySelector(selector);\n      else if (node.getElementById)\n        ref = node.getElementById(id);\n\n      if (ref || !node.templateCreator_)\n        break\n\n      node = node.templateCreator_;\n    }\n\n    return ref;\n  }\n\n  function getInstanceRoot(node) {\n    while (node.parentNode) {\n      node = node.parentNode;\n    }\n    return node.templateCreator_ ? node : null;\n  }\n\n  var Map;\n  if (global.Map && typeof global.Map.prototype.forEach === 'function') {\n    Map = global.Map;\n  } else {\n    Map = function() {\n      this.keys = [];\n      this.values = [];\n    };\n\n    Map.prototype = {\n      set: function(key, value) {\n        var index = this.keys.indexOf(key);\n        if (index < 0) {\n          this.keys.push(key);\n          this.values.push(value);\n        } else {\n          this.values[index] = value;\n        }\n      },\n\n      get: function(key) {\n        var index = this.keys.indexOf(key);\n        if (index < 0)\n          return;\n\n        return this.values[index];\n      },\n\n      delete: function(key, value) {\n        var index = this.keys.indexOf(key);\n        if (index < 0)\n          return false;\n\n        this.keys.splice(index, 1);\n        this.values.splice(index, 1);\n        return true;\n      },\n\n      forEach: function(f, opt_this) {\n        for (var i = 0; i < this.keys.length; i++)\n          f.call(opt_this || this, this.values[i], this.keys[i], this);\n      }\n    };\n  }\n\n  // JScript does not have __proto__. We wrap all object literals with\n  // createObject which uses Object.create, Object.defineProperty and\n  // Object.getOwnPropertyDescriptor to create a new object that does the exact\n  // same thing. The main downside to this solution is that we have to extract\n  // all those property descriptors for IE.\n  var createObject = ('__proto__' in {}) ?\n      function(obj) { return obj; } :\n      function(obj) {\n        var proto = obj.__proto__;\n        if (!proto)\n          return obj;\n        var newObject = Object.create(proto);\n        Object.getOwnPropertyNames(obj).forEach(function(name) {\n          Object.defineProperty(newObject, name,\n                               Object.getOwnPropertyDescriptor(obj, name));\n        });\n        return newObject;\n      };\n\n  // IE does not support have Document.prototype.contains.\n  if (typeof document.contains != 'function') {\n    Document.prototype.contains = function(node) {\n      if (node === this || node.parentNode === this)\n        return true;\n      return this.documentElement.contains(node);\n    }\n  }\n\n  var BIND = 'bind';\n  var REPEAT = 'repeat';\n  var IF = 'if';\n\n  var templateAttributeDirectives = {\n    'template': true,\n    'repeat': true,\n    'bind': true,\n    'ref': true\n  };\n\n  var semanticTemplateElements = {\n    'THEAD': true,\n    'TBODY': true,\n    'TFOOT': true,\n    'TH': true,\n    'TR': true,\n    'TD': true,\n    'COLGROUP': true,\n    'COL': true,\n    'CAPTION': true,\n    'OPTION': true,\n    'OPTGROUP': true\n  };\n\n  var hasTemplateElement = typeof HTMLTemplateElement !== 'undefined';\n  if (hasTemplateElement) {\n    // TODO(rafaelw): Remove when fix for\n    // https://codereview.chromium.org/164803002/\n    // makes it to Chrome release.\n    (function() {\n      var t = document.createElement('template');\n      var d = t.content.ownerDocument;\n      var html = d.appendChild(d.createElement('html'));\n      var head = html.appendChild(d.createElement('head'));\n      var base = d.createElement('base');\n      base.href = document.baseURI;\n      head.appendChild(base);\n    })();\n  }\n\n  var allTemplatesSelectors = 'template, ' +\n      Object.keys(semanticTemplateElements).map(function(tagName) {\n        return tagName.toLowerCase() + '[template]';\n      }).join(', ');\n\n  function isSVGTemplate(el) {\n    return el.tagName == 'template' &&\n           el.namespaceURI == 'http://www.w3.org/2000/svg';\n  }\n\n  function isHTMLTemplate(el) {\n    return el.tagName == 'TEMPLATE' &&\n           el.namespaceURI == 'http://www.w3.org/1999/xhtml';\n  }\n\n  function isAttributeTemplate(el) {\n    return Boolean(semanticTemplateElements[el.tagName] &&\n                   el.hasAttribute('template'));\n  }\n\n  function isTemplate(el) {\n    if (el.isTemplate_ === undefined)\n      el.isTemplate_ = el.tagName == 'TEMPLATE' || isAttributeTemplate(el);\n\n    return el.isTemplate_;\n  }\n\n  // FIXME: Observe templates being added/removed from documents\n  // FIXME: Expose imperative API to decorate and observe templates in\n  // \"disconnected tress\" (e.g. ShadowRoot)\n  document.addEventListener('DOMContentLoaded', function(e) {\n    bootstrapTemplatesRecursivelyFrom(document);\n    // FIXME: Is this needed? Seems like it shouldn't be.\n    Platform.performMicrotaskCheckpoint();\n  }, false);\n\n  function forAllTemplatesFrom(node, fn) {\n    var subTemplates = node.querySelectorAll(allTemplatesSelectors);\n\n    if (isTemplate(node))\n      fn(node)\n    forEach(subTemplates, fn);\n  }\n\n  function bootstrapTemplatesRecursivelyFrom(node) {\n    function bootstrap(template) {\n      if (!HTMLTemplateElement.decorate(template))\n        bootstrapTemplatesRecursivelyFrom(template.content);\n    }\n\n    forAllTemplatesFrom(node, bootstrap);\n  }\n\n  if (!hasTemplateElement) {\n    /**\n     * This represents a <template> element.\n     * @constructor\n     * @extends {HTMLElement}\n     */\n    global.HTMLTemplateElement = function() {\n      throw TypeError('Illegal constructor');\n    };\n  }\n\n  var hasProto = '__proto__' in {};\n\n  function mixin(to, from) {\n    Object.getOwnPropertyNames(from).forEach(function(name) {\n      Object.defineProperty(to, name,\n                            Object.getOwnPropertyDescriptor(from, name));\n    });\n  }\n\n  // http://dvcs.w3.org/hg/webcomponents/raw-file/tip/spec/templates/index.html#dfn-template-contents-owner\n  function getOrCreateTemplateContentsOwner(template) {\n    var doc = template.ownerDocument\n    if (!doc.defaultView)\n      return doc;\n    var d = doc.templateContentsOwner_;\n    if (!d) {\n      // TODO(arv): This should either be a Document or HTMLDocument depending\n      // on doc.\n      d = doc.implementation.createHTMLDocument('');\n      while (d.lastChild) {\n        d.removeChild(d.lastChild);\n      }\n      doc.templateContentsOwner_ = d;\n    }\n    return d;\n  }\n\n  function getTemplateStagingDocument(template) {\n    if (!template.stagingDocument_) {\n      var owner = template.ownerDocument;\n      if (!owner.stagingDocument_) {\n        owner.stagingDocument_ = owner.implementation.createHTMLDocument('');\n        owner.stagingDocument_.isStagingDocument = true;\n        // TODO(rafaelw): Remove when fix for\n        // https://codereview.chromium.org/164803002/\n        // makes it to Chrome release.\n        var base = owner.stagingDocument_.createElement('base');\n        base.href = document.baseURI;\n        owner.stagingDocument_.head.appendChild(base);\n\n        owner.stagingDocument_.stagingDocument_ = owner.stagingDocument_;\n      }\n\n      template.stagingDocument_ = owner.stagingDocument_;\n    }\n\n    return template.stagingDocument_;\n  }\n\n  // For non-template browsers, the parser will disallow <template> in certain\n  // locations, so we allow \"attribute templates\" which combine the template\n  // element with the top-level container node of the content, e.g.\n  //\n  //   <tr template repeat=\"{{ foo }}\"\" class=\"bar\"><td>Bar</td></tr>\n  //\n  // becomes\n  //\n  //   <template repeat=\"{{ foo }}\">\n  //   + #document-fragment\n  //     + <tr class=\"bar\">\n  //       + <td>Bar</td>\n  //\n  function extractTemplateFromAttributeTemplate(el) {\n    var template = el.ownerDocument.createElement('template');\n    el.parentNode.insertBefore(template, el);\n\n    var attribs = el.attributes;\n    var count = attribs.length;\n    while (count-- > 0) {\n      var attrib = attribs[count];\n      if (templateAttributeDirectives[attrib.name]) {\n        if (attrib.name !== 'template')\n          template.setAttribute(attrib.name, attrib.value);\n        el.removeAttribute(attrib.name);\n      }\n    }\n\n    return template;\n  }\n\n  function extractTemplateFromSVGTemplate(el) {\n    var template = el.ownerDocument.createElement('template');\n    el.parentNode.insertBefore(template, el);\n\n    var attribs = el.attributes;\n    var count = attribs.length;\n    while (count-- > 0) {\n      var attrib = attribs[count];\n      template.setAttribute(attrib.name, attrib.value);\n      el.removeAttribute(attrib.name);\n    }\n\n    el.parentNode.removeChild(el);\n    return template;\n  }\n\n  function liftNonNativeTemplateChildrenIntoContent(template, el, useRoot) {\n    var content = template.content;\n    if (useRoot) {\n      content.appendChild(el);\n      return;\n    }\n\n    var child;\n    while (child = el.firstChild) {\n      content.appendChild(child);\n    }\n  }\n\n  var templateObserver;\n  if (typeof MutationObserver == 'function') {\n    templateObserver = new MutationObserver(function(records) {\n      for (var i = 0; i < records.length; i++) {\n        records[i].target.refChanged_();\n      }\n    });\n  }\n\n  /**\n   * Ensures proper API and content model for template elements.\n   * @param {HTMLTemplateElement} opt_instanceRef The template element which\n   *     |el| template element will return as the value of its ref(), and whose\n   *     content will be used as source when createInstance() is invoked.\n   */\n  HTMLTemplateElement.decorate = function(el, opt_instanceRef) {\n    if (el.templateIsDecorated_)\n      return false;\n\n    var templateElement = el;\n    templateElement.templateIsDecorated_ = true;\n\n    var isNativeHTMLTemplate = isHTMLTemplate(templateElement) &&\n                               hasTemplateElement;\n    var bootstrapContents = isNativeHTMLTemplate;\n    var liftContents = !isNativeHTMLTemplate;\n    var liftRoot = false;\n\n    if (!isNativeHTMLTemplate) {\n      if (isAttributeTemplate(templateElement)) {\n        assert(!opt_instanceRef);\n        templateElement = extractTemplateFromAttributeTemplate(el);\n        templateElement.templateIsDecorated_ = true;\n        isNativeHTMLTemplate = hasTemplateElement;\n        liftRoot = true;\n      } else if (isSVGTemplate(templateElement)) {\n        templateElement = extractTemplateFromSVGTemplate(el);\n        templateElement.templateIsDecorated_ = true;\n        isNativeHTMLTemplate = hasTemplateElement;\n      }\n    }\n\n    if (!isNativeHTMLTemplate) {\n      fixTemplateElementPrototype(templateElement);\n      var doc = getOrCreateTemplateContentsOwner(templateElement);\n      templateElement.content_ = doc.createDocumentFragment();\n    }\n\n    if (opt_instanceRef) {\n      // template is contained within an instance, its direct content must be\n      // empty\n      templateElement.instanceRef_ = opt_instanceRef;\n    } else if (liftContents) {\n      liftNonNativeTemplateChildrenIntoContent(templateElement,\n                                               el,\n                                               liftRoot);\n    } else if (bootstrapContents) {\n      bootstrapTemplatesRecursivelyFrom(templateElement.content);\n    }\n\n    return true;\n  };\n\n  // TODO(rafaelw): This used to decorate recursively all templates from a given\n  // node. This happens by default on 'DOMContentLoaded', but may be needed\n  // in subtrees not descendent from document (e.g. ShadowRoot).\n  // Review whether this is the right public API.\n  HTMLTemplateElement.bootstrap = bootstrapTemplatesRecursivelyFrom;\n\n  var htmlElement = global.HTMLUnknownElement || HTMLElement;\n\n  var contentDescriptor = {\n    get: function() {\n      return this.content_;\n    },\n    enumerable: true,\n    configurable: true\n  };\n\n  if (!hasTemplateElement) {\n    // Gecko is more picky with the prototype than WebKit. Make sure to use the\n    // same prototype as created in the constructor.\n    HTMLTemplateElement.prototype = Object.create(htmlElement.prototype);\n\n    Object.defineProperty(HTMLTemplateElement.prototype, 'content',\n                          contentDescriptor);\n  }\n\n  function fixTemplateElementPrototype(el) {\n    if (hasProto)\n      el.__proto__ = HTMLTemplateElement.prototype;\n    else\n      mixin(el, HTMLTemplateElement.prototype);\n  }\n\n  function ensureSetModelScheduled(template) {\n    if (!template.setModelFn_) {\n      template.setModelFn_ = function() {\n        template.setModelFnScheduled_ = false;\n        var map = getBindings(template,\n            template.delegate_ && template.delegate_.prepareBinding);\n        processBindings(template, map, template.model_);\n      };\n    }\n\n    if (!template.setModelFnScheduled_) {\n      template.setModelFnScheduled_ = true;\n      Observer.runEOM_(template.setModelFn_);\n    }\n  }\n\n  mixin(HTMLTemplateElement.prototype, {\n    bind: function(name, value, oneTime) {\n      if (name != 'ref')\n        return Element.prototype.bind.call(this, name, value, oneTime);\n\n      var self = this;\n      var ref = oneTime ? value : value.open(function(ref) {\n        self.setAttribute('ref', ref);\n        self.refChanged_();\n      });\n\n      this.setAttribute('ref', ref);\n      this.refChanged_();\n      if (oneTime)\n        return;\n\n      if (!this.bindings_) {\n        this.bindings_ = { ref: value };\n      } else {\n        this.bindings_.ref = value;\n      }\n\n      return value;\n    },\n\n    processBindingDirectives_: function(directives) {\n      if (this.iterator_)\n        this.iterator_.closeDeps();\n\n      if (!directives.if && !directives.bind && !directives.repeat) {\n        if (this.iterator_) {\n          this.iterator_.close();\n          this.iterator_ = undefined;\n        }\n\n        return;\n      }\n\n      if (!this.iterator_) {\n        this.iterator_ = new TemplateIterator(this);\n      }\n\n      this.iterator_.updateDependencies(directives, this.model_);\n\n      if (templateObserver) {\n        templateObserver.observe(this, { attributes: true,\n                                         attributeFilter: ['ref'] });\n      }\n\n      return this.iterator_;\n    },\n\n    createInstance: function(model, bindingDelegate, delegate_) {\n      if (bindingDelegate)\n        delegate_ = this.newDelegate_(bindingDelegate);\n      else if (!delegate_)\n        delegate_ = this.delegate_;\n\n      if (!this.refContent_)\n        this.refContent_ = this.ref_.content;\n      var content = this.refContent_;\n      if (content.firstChild === null)\n        return emptyInstance;\n\n      var map = getInstanceBindingMap(content, delegate_);\n      var stagingDocument = getTemplateStagingDocument(this);\n      var instance = stagingDocument.createDocumentFragment();\n      instance.templateCreator_ = this;\n      instance.protoContent_ = content;\n      instance.bindings_ = [];\n      instance.terminator_ = null;\n      var instanceRecord = instance.templateInstance_ = {\n        firstNode: null,\n        lastNode: null,\n        model: model\n      };\n\n      var i = 0;\n      var collectTerminator = false;\n      for (var child = content.firstChild; child; child = child.nextSibling) {\n        // The terminator of the instance is the clone of the last child of the\n        // content. If the last child is an active template, it may produce\n        // instances as a result of production, so simply collecting the last\n        // child of the instance after it has finished producing may be wrong.\n        if (child.nextSibling === null)\n          collectTerminator = true;\n\n        var clone = cloneAndBindInstance(child, instance, stagingDocument,\n                                         map.children[i++],\n                                         model,\n                                         delegate_,\n                                         instance.bindings_);\n        clone.templateInstance_ = instanceRecord;\n        if (collectTerminator)\n          instance.terminator_ = clone;\n      }\n\n      instanceRecord.firstNode = instance.firstChild;\n      instanceRecord.lastNode = instance.lastChild;\n      instance.templateCreator_ = undefined;\n      instance.protoContent_ = undefined;\n      return instance;\n    },\n\n    get model() {\n      return this.model_;\n    },\n\n    set model(model) {\n      this.model_ = model;\n      ensureSetModelScheduled(this);\n    },\n\n    get bindingDelegate() {\n      return this.delegate_ && this.delegate_.raw;\n    },\n\n    refChanged_: function() {\n      if (!this.iterator_ || this.refContent_ === this.ref_.content)\n        return;\n\n      this.refContent_ = undefined;\n      this.iterator_.valueChanged();\n      this.iterator_.updateIteratedValue();\n    },\n\n    clear: function() {\n      this.model_ = undefined;\n      this.delegate_ = undefined;\n      if (this.bindings_ && this.bindings_.ref)\n        this.bindings_.ref.close()\n      this.refContent_ = undefined;\n      if (!this.iterator_)\n        return;\n      this.iterator_.valueChanged();\n      this.iterator_.close()\n      this.iterator_ = undefined;\n    },\n\n    setDelegate_: function(delegate) {\n      this.delegate_ = delegate;\n      this.bindingMap_ = undefined;\n      if (this.iterator_) {\n        this.iterator_.instancePositionChangedFn_ = undefined;\n        this.iterator_.instanceModelFn_ = undefined;\n      }\n    },\n\n    newDelegate_: function(bindingDelegate) {\n      if (!bindingDelegate)\n        return;\n\n      function delegateFn(name) {\n        var fn = bindingDelegate && bindingDelegate[name];\n        if (typeof fn != 'function')\n          return;\n\n        return function() {\n          return fn.apply(bindingDelegate, arguments);\n        };\n      }\n\n      return {\n        bindingMaps: {},\n        raw: bindingDelegate,\n        prepareBinding: delegateFn('prepareBinding'),\n        prepareInstanceModel: delegateFn('prepareInstanceModel'),\n        prepareInstancePositionChanged:\n            delegateFn('prepareInstancePositionChanged')\n      };\n    },\n\n    set bindingDelegate(bindingDelegate) {\n      if (this.delegate_) {\n        throw Error('Template must be cleared before a new bindingDelegate ' +\n                    'can be assigned');\n      }\n\n      this.setDelegate_(this.newDelegate_(bindingDelegate));\n    },\n\n    get ref_() {\n      var ref = searchRefId(this, this.getAttribute('ref'));\n      if (!ref)\n        ref = this.instanceRef_;\n\n      if (!ref)\n        return this;\n\n      var nextRef = ref.ref_;\n      return nextRef ? nextRef : ref;\n    }\n  });\n\n  // Returns\n  //   a) undefined if there are no mustaches.\n  //   b) [TEXT, (ONE_TIME?, PATH, DELEGATE_FN, TEXT)+] if there is at least one mustache.\n  function parseMustaches(s, name, node, prepareBindingFn) {\n    if (!s || !s.length)\n      return;\n\n    var tokens;\n    var length = s.length;\n    var startIndex = 0, lastIndex = 0, endIndex = 0;\n    var onlyOneTime = true;\n    while (lastIndex < length) {\n      var startIndex = s.indexOf('{{', lastIndex);\n      var oneTimeStart = s.indexOf('[[', lastIndex);\n      var oneTime = false;\n      var terminator = '}}';\n\n      if (oneTimeStart >= 0 &&\n          (startIndex < 0 || oneTimeStart < startIndex)) {\n        startIndex = oneTimeStart;\n        oneTime = true;\n        terminator = ']]';\n      }\n\n      endIndex = startIndex < 0 ? -1 : s.indexOf(terminator, startIndex + 2);\n\n      if (endIndex < 0) {\n        if (!tokens)\n          return;\n\n        tokens.push(s.slice(lastIndex)); // TEXT\n        break;\n      }\n\n      tokens = tokens || [];\n      tokens.push(s.slice(lastIndex, startIndex)); // TEXT\n      var pathString = s.slice(startIndex + 2, endIndex).trim();\n      tokens.push(oneTime); // ONE_TIME?\n      onlyOneTime = onlyOneTime && oneTime;\n      var delegateFn = prepareBindingFn &&\n                       prepareBindingFn(pathString, name, node);\n      // Don't try to parse the expression if there's a prepareBinding function\n      if (delegateFn == null) {\n        tokens.push(Path.get(pathString)); // PATH\n      } else {\n        tokens.push(null);\n      }\n      tokens.push(delegateFn); // DELEGATE_FN\n      lastIndex = endIndex + 2;\n    }\n\n    if (lastIndex === length)\n      tokens.push(''); // TEXT\n\n    tokens.hasOnePath = tokens.length === 5;\n    tokens.isSimplePath = tokens.hasOnePath &&\n                          tokens[0] == '' &&\n                          tokens[4] == '';\n    tokens.onlyOneTime = onlyOneTime;\n\n    tokens.combinator = function(values) {\n      var newValue = tokens[0];\n\n      for (var i = 1; i < tokens.length; i += 4) {\n        var value = tokens.hasOnePath ? values : values[(i - 1) / 4];\n        if (value !== undefined)\n          newValue += value;\n        newValue += tokens[i + 3];\n      }\n\n      return newValue;\n    }\n\n    return tokens;\n  };\n\n  function processOneTimeBinding(name, tokens, node, model) {\n    if (tokens.hasOnePath) {\n      var delegateFn = tokens[3];\n      var value = delegateFn ? delegateFn(model, node, true) :\n                               tokens[2].getValueFrom(model);\n      return tokens.isSimplePath ? value : tokens.combinator(value);\n    }\n\n    var values = [];\n    for (var i = 1; i < tokens.length; i += 4) {\n      var delegateFn = tokens[i + 2];\n      values[(i - 1) / 4] = delegateFn ? delegateFn(model, node) :\n          tokens[i + 1].getValueFrom(model);\n    }\n\n    return tokens.combinator(values);\n  }\n\n  function processSinglePathBinding(name, tokens, node, model) {\n    var delegateFn = tokens[3];\n    var observer = delegateFn ? delegateFn(model, node, false) :\n        new PathObserver(model, tokens[2]);\n\n    return tokens.isSimplePath ? observer :\n        new ObserverTransform(observer, tokens.combinator);\n  }\n\n  function processBinding(name, tokens, node, model) {\n    if (tokens.onlyOneTime)\n      return processOneTimeBinding(name, tokens, node, model);\n\n    if (tokens.hasOnePath)\n      return processSinglePathBinding(name, tokens, node, model);\n\n    var observer = new CompoundObserver();\n\n    for (var i = 1; i < tokens.length; i += 4) {\n      var oneTime = tokens[i];\n      var delegateFn = tokens[i + 2];\n\n      if (delegateFn) {\n        var value = delegateFn(model, node, oneTime);\n        if (oneTime)\n          observer.addPath(value)\n        else\n          observer.addObserver(value);\n        continue;\n      }\n\n      var path = tokens[i + 1];\n      if (oneTime)\n        observer.addPath(path.getValueFrom(model))\n      else\n        observer.addPath(model, path);\n    }\n\n    return new ObserverTransform(observer, tokens.combinator);\n  }\n\n  function processBindings(node, bindings, model, instanceBindings) {\n    for (var i = 0; i < bindings.length; i += 2) {\n      var name = bindings[i]\n      var tokens = bindings[i + 1];\n      var value = processBinding(name, tokens, node, model);\n      var binding = node.bind(name, value, tokens.onlyOneTime);\n      if (binding && instanceBindings)\n        instanceBindings.push(binding);\n    }\n\n    node.bindFinished();\n    if (!bindings.isTemplate)\n      return;\n\n    node.model_ = model;\n    var iter = node.processBindingDirectives_(bindings);\n    if (instanceBindings && iter)\n      instanceBindings.push(iter);\n  }\n\n  function parseWithDefault(el, name, prepareBindingFn) {\n    var v = el.getAttribute(name);\n    return parseMustaches(v == '' ? '{{}}' : v, name, el, prepareBindingFn);\n  }\n\n  function parseAttributeBindings(element, prepareBindingFn) {\n    assert(element);\n\n    var bindings = [];\n    var ifFound = false;\n    var bindFound = false;\n\n    for (var i = 0; i < element.attributes.length; i++) {\n      var attr = element.attributes[i];\n      var name = attr.name;\n      var value = attr.value;\n\n      // Allow bindings expressed in attributes to be prefixed with underbars.\n      // We do this to allow correct semantics for browsers that don't implement\n      // <template> where certain attributes might trigger side-effects -- and\n      // for IE which sanitizes certain attributes, disallowing mustache\n      // replacements in their text.\n      while (name[0] === '_') {\n        name = name.substring(1);\n      }\n\n      if (isTemplate(element) &&\n          (name === IF || name === BIND || name === REPEAT)) {\n        continue;\n      }\n\n      var tokens = parseMustaches(value, name, element,\n                                  prepareBindingFn);\n      if (!tokens)\n        continue;\n\n      bindings.push(name, tokens);\n    }\n\n    if (isTemplate(element)) {\n      bindings.isTemplate = true;\n      bindings.if = parseWithDefault(element, IF, prepareBindingFn);\n      bindings.bind = parseWithDefault(element, BIND, prepareBindingFn);\n      bindings.repeat = parseWithDefault(element, REPEAT, prepareBindingFn);\n\n      if (bindings.if && !bindings.bind && !bindings.repeat)\n        bindings.bind = parseMustaches('{{}}', BIND, element, prepareBindingFn);\n    }\n\n    return bindings;\n  }\n\n  function getBindings(node, prepareBindingFn) {\n    if (node.nodeType === Node.ELEMENT_NODE)\n      return parseAttributeBindings(node, prepareBindingFn);\n\n    if (node.nodeType === Node.TEXT_NODE) {\n      var tokens = parseMustaches(node.data, 'textContent', node,\n                                  prepareBindingFn);\n      if (tokens)\n        return ['textContent', tokens];\n    }\n\n    return [];\n  }\n\n  function cloneAndBindInstance(node, parent, stagingDocument, bindings, model,\n                                delegate,\n                                instanceBindings,\n                                instanceRecord) {\n    var clone = parent.appendChild(stagingDocument.importNode(node, false));\n\n    var i = 0;\n    for (var child = node.firstChild; child; child = child.nextSibling) {\n      cloneAndBindInstance(child, clone, stagingDocument,\n                            bindings.children[i++],\n                            model,\n                            delegate,\n                            instanceBindings);\n    }\n\n    if (bindings.isTemplate) {\n      HTMLTemplateElement.decorate(clone, node);\n      if (delegate)\n        clone.setDelegate_(delegate);\n    }\n\n    processBindings(clone, bindings, model, instanceBindings);\n    return clone;\n  }\n\n  function createInstanceBindingMap(node, prepareBindingFn) {\n    var map = getBindings(node, prepareBindingFn);\n    map.children = {};\n    var index = 0;\n    for (var child = node.firstChild; child; child = child.nextSibling) {\n      map.children[index++] = createInstanceBindingMap(child, prepareBindingFn);\n    }\n\n    return map;\n  }\n\n  var contentUidCounter = 1;\n\n  // TODO(rafaelw): Setup a MutationObserver on content which clears the id\n  // so that bindingMaps regenerate when the template.content changes.\n  function getContentUid(content) {\n    var id = content.id_;\n    if (!id)\n      id = content.id_ = contentUidCounter++;\n    return id;\n  }\n\n  // Each delegate is associated with a set of bindingMaps, one for each\n  // content which may be used by a template. The intent is that each binding\n  // delegate gets the opportunity to prepare the instance (via the prepare*\n  // delegate calls) once across all uses.\n  // TODO(rafaelw): Separate out the parse map from the binding map. In the\n  // current implementation, if two delegates need a binding map for the same\n  // content, the second will have to reparse.\n  function getInstanceBindingMap(content, delegate_) {\n    var contentId = getContentUid(content);\n    if (delegate_) {\n      var map = delegate_.bindingMaps[contentId];\n      if (!map) {\n        map = delegate_.bindingMaps[contentId] =\n            createInstanceBindingMap(content, delegate_.prepareBinding) || [];\n      }\n      return map;\n    }\n\n    var map = content.bindingMap_;\n    if (!map) {\n      map = content.bindingMap_ =\n          createInstanceBindingMap(content, undefined) || [];\n    }\n    return map;\n  }\n\n  Object.defineProperty(Node.prototype, 'templateInstance', {\n    get: function() {\n      var instance = this.templateInstance_;\n      return instance ? instance :\n          (this.parentNode ? this.parentNode.templateInstance : undefined);\n    }\n  });\n\n  var emptyInstance = document.createDocumentFragment();\n  emptyInstance.bindings_ = [];\n  emptyInstance.terminator_ = null;\n\n  function TemplateIterator(templateElement) {\n    this.closed = false;\n    this.templateElement_ = templateElement;\n    this.instances = [];\n    this.deps = undefined;\n    this.iteratedValue = [];\n    this.presentValue = undefined;\n    this.arrayObserver = undefined;\n  }\n\n  TemplateIterator.prototype = {\n    closeDeps: function() {\n      var deps = this.deps;\n      if (deps) {\n        if (deps.ifOneTime === false)\n          deps.ifValue.close();\n        if (deps.oneTime === false)\n          deps.value.close();\n      }\n    },\n\n    updateDependencies: function(directives, model) {\n      this.closeDeps();\n\n      var deps = this.deps = {};\n      var template = this.templateElement_;\n\n      if (directives.if) {\n        deps.hasIf = true;\n        deps.ifOneTime = directives.if.onlyOneTime;\n        deps.ifValue = processBinding(IF, directives.if, template, model);\n\n        // oneTime if & predicate is false. nothing else to do.\n        if (deps.ifOneTime && !deps.ifValue) {\n          this.updateIteratedValue();\n          return;\n        }\n\n        if (!deps.ifOneTime)\n          deps.ifValue.open(this.updateIteratedValue, this);\n      }\n\n      if (directives.repeat) {\n        deps.repeat = true;\n        deps.oneTime = directives.repeat.onlyOneTime;\n        deps.value = processBinding(REPEAT, directives.repeat, template, model);\n      } else {\n        deps.repeat = false;\n        deps.oneTime = directives.bind.onlyOneTime;\n        deps.value = processBinding(BIND, directives.bind, template, model);\n      }\n\n      if (!deps.oneTime)\n        deps.value.open(this.updateIteratedValue, this);\n\n      this.updateIteratedValue();\n    },\n\n    updateIteratedValue: function() {\n      if (this.deps.hasIf) {\n        var ifValue = this.deps.ifValue;\n        if (!this.deps.ifOneTime)\n          ifValue = ifValue.discardChanges();\n        if (!ifValue) {\n          this.valueChanged();\n          return;\n        }\n      }\n\n      var value = this.deps.value;\n      if (!this.deps.oneTime)\n        value = value.discardChanges();\n      if (!this.deps.repeat)\n        value = [value];\n      var observe = this.deps.repeat &&\n                    !this.deps.oneTime &&\n                    Array.isArray(value);\n      this.valueChanged(value, observe);\n    },\n\n    valueChanged: function(value, observeValue) {\n      if (!Array.isArray(value))\n        value = [];\n\n      if (value === this.iteratedValue)\n        return;\n\n      this.unobserve();\n      this.presentValue = value;\n      if (observeValue) {\n        this.arrayObserver = new ArrayObserver(this.presentValue);\n        this.arrayObserver.open(this.handleSplices, this);\n      }\n\n      this.handleSplices(ArrayObserver.calculateSplices(this.presentValue,\n                                                        this.iteratedValue));\n    },\n\n    getLastInstanceNode: function(index) {\n      if (index == -1)\n        return this.templateElement_;\n      var instance = this.instances[index];\n      var terminator = instance.terminator_;\n      if (!terminator)\n        return this.getLastInstanceNode(index - 1);\n\n      if (terminator.nodeType !== Node.ELEMENT_NODE ||\n          this.templateElement_ === terminator) {\n        return terminator;\n      }\n\n      var subtemplateIterator = terminator.iterator_;\n      if (!subtemplateIterator)\n        return terminator;\n\n      return subtemplateIterator.getLastTemplateNode();\n    },\n\n    getLastTemplateNode: function() {\n      return this.getLastInstanceNode(this.instances.length - 1);\n    },\n\n    insertInstanceAt: function(index, fragment) {\n      var previousInstanceLast = this.getLastInstanceNode(index - 1);\n      var parent = this.templateElement_.parentNode;\n      this.instances.splice(index, 0, fragment);\n\n      parent.insertBefore(fragment, previousInstanceLast.nextSibling);\n    },\n\n    extractInstanceAt: function(index) {\n      var previousInstanceLast = this.getLastInstanceNode(index - 1);\n      var lastNode = this.getLastInstanceNode(index);\n      var parent = this.templateElement_.parentNode;\n      var instance = this.instances.splice(index, 1)[0];\n\n      while (lastNode !== previousInstanceLast) {\n        var node = previousInstanceLast.nextSibling;\n        if (node == lastNode)\n          lastNode = previousInstanceLast;\n\n        instance.appendChild(parent.removeChild(node));\n      }\n\n      return instance;\n    },\n\n    getDelegateFn: function(fn) {\n      fn = fn && fn(this.templateElement_);\n      return typeof fn === 'function' ? fn : null;\n    },\n\n    handleSplices: function(splices) {\n      if (this.closed || !splices.length)\n        return;\n\n      var template = this.templateElement_;\n\n      if (!template.parentNode) {\n        this.close();\n        return;\n      }\n\n      ArrayObserver.applySplices(this.iteratedValue, this.presentValue,\n                                 splices);\n\n      var delegate = template.delegate_;\n      if (this.instanceModelFn_ === undefined) {\n        this.instanceModelFn_ =\n            this.getDelegateFn(delegate && delegate.prepareInstanceModel);\n      }\n\n      if (this.instancePositionChangedFn_ === undefined) {\n        this.instancePositionChangedFn_ =\n            this.getDelegateFn(delegate &&\n                               delegate.prepareInstancePositionChanged);\n      }\n\n      // Instance Removals\n      var instanceCache = new Map;\n      var removeDelta = 0;\n      for (var i = 0; i < splices.length; i++) {\n        var splice = splices[i];\n        var removed = splice.removed;\n        for (var j = 0; j < removed.length; j++) {\n          var model = removed[j];\n          var instance = this.extractInstanceAt(splice.index + removeDelta);\n          if (instance !== emptyInstance) {\n            instanceCache.set(model, instance);\n          }\n        }\n\n        removeDelta -= splice.addedCount;\n      }\n\n      // Instance Insertions\n      for (var i = 0; i < splices.length; i++) {\n        var splice = splices[i];\n        var addIndex = splice.index;\n        for (; addIndex < splice.index + splice.addedCount; addIndex++) {\n          var model = this.iteratedValue[addIndex];\n          var instance = instanceCache.get(model);\n          if (instance) {\n            instanceCache.delete(model);\n          } else {\n            if (this.instanceModelFn_) {\n              model = this.instanceModelFn_(model);\n            }\n\n            if (model === undefined) {\n              instance = emptyInstance;\n            } else {\n              instance = template.createInstance(model, undefined, delegate);\n            }\n          }\n\n          this.insertInstanceAt(addIndex, instance);\n        }\n      }\n\n      instanceCache.forEach(function(instance) {\n        this.closeInstanceBindings(instance);\n      }, this);\n\n      if (this.instancePositionChangedFn_)\n        this.reportInstancesMoved(splices);\n    },\n\n    reportInstanceMoved: function(index) {\n      var instance = this.instances[index];\n      if (instance === emptyInstance)\n        return;\n\n      this.instancePositionChangedFn_(instance.templateInstance_, index);\n    },\n\n    reportInstancesMoved: function(splices) {\n      var index = 0;\n      var offset = 0;\n      for (var i = 0; i < splices.length; i++) {\n        var splice = splices[i];\n        if (offset != 0) {\n          while (index < splice.index) {\n            this.reportInstanceMoved(index);\n            index++;\n          }\n        } else {\n          index = splice.index;\n        }\n\n        while (index < splice.index + splice.addedCount) {\n          this.reportInstanceMoved(index);\n          index++;\n        }\n\n        offset += splice.addedCount - splice.removed.length;\n      }\n\n      if (offset == 0)\n        return;\n\n      var length = this.instances.length;\n      while (index < length) {\n        this.reportInstanceMoved(index);\n        index++;\n      }\n    },\n\n    closeInstanceBindings: function(instance) {\n      var bindings = instance.bindings_;\n      for (var i = 0; i < bindings.length; i++) {\n        bindings[i].close();\n      }\n    },\n\n    unobserve: function() {\n      if (!this.arrayObserver)\n        return;\n\n      this.arrayObserver.close();\n      this.arrayObserver = undefined;\n    },\n\n    close: function() {\n      if (this.closed)\n        return;\n      this.unobserve();\n      for (var i = 0; i < this.instances.length; i++) {\n        this.closeInstanceBindings(this.instances[i]);\n      }\n\n      this.instances.length = 0;\n      this.closeDeps();\n      this.templateElement_.iterator_ = undefined;\n      this.closed = true;\n    }\n  };\n\n  // Polyfill-specific API.\n  HTMLTemplateElement.forAllTemplatesFrom_ = forAllTemplatesFrom;\n})(this);\n",
			"file": "/Users/ramakay/Projects/everest-club-monaco/clubmonaco/fe-build/node_modules/templatebinding/TemplateBinding.js",
			"file_size": 92336,
			"file_write_time": 131100628540000000,
			"settings":
			{
				"buffer_size": 92309,
				"line_ending": "Unix"
			}
		},
		{
			"settings":
			{
				"buffer_size": 0,
				"line_ending": "Unix"
			}
		}
	],
	"build_system": "",
	"build_system_choices":
	[
	],
	"build_varint": "",
	"command_palette":
	{
		"height": 91.0,
		"last_filter": "set syntax:babe",
		"selected_items":
		[
			[
				"set syntax:babe",
				"Set Syntax: JavaScript (Babel)"
			],
			[
				"format",
				"Format: Javascript"
			],
			[
				"form",
				"Format Code"
			],
			[
				"pack",
				"Package Control: Install Package"
			],
			[
				"for",
				"Format: Javascript"
			],
			[
				"sublimelinter",
				"SublimeLinter: Make Warnings Passive"
			],
			[
				"comment",
				"Toggle Block Comment"
			],
			[
				"sublimerge",
				"Sublimerge"
			],
			[
				"sublmier",
				"Sublimerge"
			],
			[
				"sublimerg",
				"Sublimerge"
			],
			[
				"merge",
				"Sublimerge"
			],
			[
				"sublime",
				"SublimeLinter: Choose Lint Mode"
			],
			[
				"package linte",
				"Package Control: Install Package"
			],
			[
				"sublimelinter:inst",
				"SublimeLinter: Lint This View"
			],
			[
				"babel",
				"Set Syntax: JavaScript (Babel)"
			],
			[
				"package",
				"Package Control: Install Package"
			],
			[
				"packa",
				"Package Control: Install Package"
			],
			[
				"prett",
				"Pretty JSON: Format (Pretty Print) JSON"
			],
			[
				"package control: inst",
				"Package Control: Install Package"
			],
			[
				"package control: remo",
				"Package Control: Remove Package"
			],
			[
				"browse",
				"Preferences: Browse Packages"
			],
			[
				"pac",
				"Package Control: Install Package"
			]
		],
		"width": 449.0
	},
	"console":
	{
		"height": 126.0,
		"history":
		[
			"import urllib.request,os,hashlib; h = '2915d1851351e5ee549c20394736b442' + '8bc59f460fa1548d1514676163dafc88'; pf = 'Package Control.sublime-package'; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( 'http://packagecontrol.io/' + pf.replace(' ', '%20')).read(); dh = hashlib.sha256(by).hexdigest(); print('Error validating download (got %s instead of %s), please try manual install' % (dh, h)) if dh != h else open(os.path.join( ipp, pf), 'wb' ).write(by)"
		]
	},
	"distraction_free":
	{
		"menu_visible": true,
		"show_minimap": false,
		"show_open_files": false,
		"show_tabs": false,
		"side_bar_visible": false,
		"status_bar_visible": false
	},
	"expanded_folders":
	[
		"/Users/ramakay/Projects/ccremix"
	],
	"file_history":
	[
		"/Users/ramakay/Projects/everest-club-monaco/clubmonaco/src/main/resources/templates/index.html",
		"/Users/ramakay/Projects/everest-club-monaco/clubmonaco/src/main/resources/templates/error.html",
		"/Users/ramakay/Projects/everest-club-monaco/clubmonaco/src/main/resources/templates/addToCart.html",
		"/Users/ramakay/Projects/everest-club-monaco/clubmonaco/fe-build/src/js/actions/cart.js",
		"/Users/ramakay/Projects/everest-club-monaco/clubmonaco/fe-build/src/js/templates/pageFunctions.js",
		"/Users/ramakay/Projects/everest-club-monaco/clubmonaco/fe-build/src/js/helpers/viewportHelper.js",
		"/Users/ramakay/Projects/everest-club-monaco/clubmonaco/fe-build/src/js/helpers/helpers.js",
		"/Users/ramakay/Projects/everest/cart-es6.js",
		"/Users/ramakay/Projects/everest-club-monaco/clubmonaco/src/main/resources/templates/product.js",
		"/Users/ramakay/Projects/everest-club-monaco/clubmonaco/src/main/resources/templates/fragments/product/add-to-cart/_add-to-cart.js",
		"/Users/ramakay/Projects/everest-club-monaco/clubmonaco/src/main/java/com/clubmonaco/ClubmonacoApplication.java",
		"/Users/ramakay/Projects/everest-club-monaco/clubmonaco/target/clubmonaco-0.0.1-SNAPSHOT.jar",
		"/Users/ramakay/Projects/everest-club-monaco/clubmonaco/src/main/resources/templates/fragments/product/add-to-cart/add-to-cart.html",
		"/Users/ramakay/Projects/everest-club-monaco/clubmonaco/src/main/resources/templates/fragments/header.html",
		"/Users/ramakay/Projects/everest-club-monaco/clubmonaco/src/main/resources/templates/includes.html",
		"/Users/ramakay/Projects/everest-club-monaco/clubmonaco/fe-build/src/index.js",
		"/Users/ramakay/Projects/everest-club-monaco/clubmonaco/fe-build/src/helpers/ajax-factory.js",
		"/Users/ramakay/Projects/everest-club-monaco/clubmonaco/fe-build/src/cart.js",
		"/Users/ramakay/Projects/everest-club-monaco/clubmonaco/src/main/resources/templates/fragments/state.html",
		"/Users/ramakay/Projects/everest-club-monaco/clubmonaco/src/main/resources/templates/head.html",
		"/Users/ramakay/Projects/everest-club-monaco/clubmonaco/fe-build/index.html",
		"/Users/ramakay/Projects/everest-club-monaco/clubmonaco/fe-build/package.json",
		"/Users/ramakay/Projects/CM-Prototype/app/components/styleguide/gridSystem.jsx",
		"/Users/ramakay/Projects/CM-Prototype/app/containers/Styleguide.jsx",
		"/Users/ramakay/Projects/CM-Prototype/app/containers/Grid.jsx",
		"/Users/ramakay/Projects/CM-Prototype/server/index.js",
		"/Users/ramakay/Projects/CM-Prototype/.gitignore",
		"/Users/ramakay/Projects/cm-poc/hybris-cm-poc/cm-experience/app/actions/navigation.js",
		"/Users/ramakay/Projects/cm-poc/hybris-cm-poc/cm-experience/server/controllers/channel.js",
		"/Users/ramakay/Projects/cm-poc/hybris-cm-poc/cm-experience/server/index.js",
		"/Users/ramakay/Projects/everest/cm-experience/server/controllers/opentext/helper.js",
		"/Users/ramakay/Projects/everest/cm-experience/app/store/configureStore.js",
		"/Users/ramakay/Projects/everest/cm-experience/app/reducers/topic.js",
		"/Users/ramakay/Projects/everest/cm-experience/app/reducers/content.js",
		"/Users/ramakay/Projects/everest/cm-experience/app/actions/users.js",
		"/Users/ramakay/Projects/everest/cm-experience/app/actions/content.js",
		"/Users/ramakay/Projects/everest/cm-experience/server/controllers/content.js",
		"/Users/ramakay/Projects/everest/cm-experience/README.md",
		"/Users/ramakay/Projects/everest/cm-experience/app/constants/index.js",
		"/Users/ramakay/Projects/sublimeworkspaces/cm.sublime-project",
		"/Users/ramakay/Projects/everest/cm-experience/app/actions/topics.js",
		"/Users/ramakay/Projects/everest/cm-experience/app/actions/store.js",
		"/Users/ramakay/Projects/everest/cm-experience/app/routes.jsx",
		"/Users/ramakay/Projects/everest/cm-experience/server/controllers/channel.js",
		"/Users/ramakay/Projects/everest/cm-experience/app/actions/navigation.js",
		"/Users/ramakay/Projects/everest/cm-experience/app/containers/Grid.jsx",
		"/Users/ramakay/.zshrc",
		"/Users/ramakay/Projects/everest/cm-experience/app/reducers/store.js",
		"/Users/ramakay/Projects/everest/cm-experience/app/server.jsx",
		"/Users/ramakay/Projects/everest/cm-experience/server/controllers/users.js",
		"/Users/ramakay/Projects/everest/cm-experience/app/containers/Login.jsx",
		"/Users/ramakay/Projects/everest/cm-experience/server/config/routes.js",
		"/Users/ramakay/Projects/everest/cm-experience/app/containers/Vote.jsx",
		"/Users/ramakay/Projects/everest/cm-experience/server/controllers/topics.js",
		"/Users/ramakay/Library/Application Support/Sublime Text 3/Packages/User/Preferences.sublime-settings",
		"/Users/ramakay/Projects/everest/cm-experience/app/reducers/user.js",
		"/Users/ramakay/Projects/everest/cm-experience/app/actions/content",
		"/Users/ramakay/Projects/everest/cm-experience/server/models/content.js",
		"/Users/ramakay/Projects/everest/cm-experience/app/reducers/index.js",
		"/Users/ramakay/Projects/everest/cm-experience/app/containers/App.jsx",
		"/Users/ramakay/Projects/everest/cm-experience/server/index.js",
		"/Users/ramakay/Projects/everest/cm-experience/public/assets/app.server.js",
		"/Users/ramakay/Desktop/package.json",
		"/Users/ramakay/Desktop/RE Difference in fonts  Web fonts and Prototype.msg",
		"/Users/ramakay/.bash_profile",
		"/Volumes/Projects/everest/hybris/bin/custom/ralphlauren/ralphlaurenstorefront/web/webroot/WEB-INF/_ui-src/responsive/rl-fe-source/cyo/dev-server.js",
		"/Volumes/Projects/everest/hybris/bin/custom/ralphlauren/ralphlaurenstorefront/web/webroot/_ui/responsive/rl-fe-build/js/pages/productDetailAdv.js",
		"/Volumes/Projects/everest/everest.sublime-project",
		"/Volumes/Projects/everest/hybris/bin/custom/ralphlauren/ralphlaurenstorefront/gulp-tasks/optimizeJSProd.js",
		"/Volumes/Projects/everest/hybris/bin/custom/ralphlauren/ralphlaurenstorefront/gulp-tasks/launchcyo.js",
		"/Volumes/Projects/everest/hybris/bin/custom/ralphlauren/ralphlaurenstorefront/package.json",
		"/Users/ramakay/yourhealth/index.js",
		"/Users/ramakay/yourhealth/node_modules/fitbit-node/fitbit-api-client.js",
		"/Users/ramakay/yourhealth/node_modules/fitbit-node/example.js",
		"/Users/ramakay/yourhealth/.gitignore",
		"/Applications/AMPPS/www/fbadslocal/custom_audiences.php",
		"/Users/ramakay/Projects/timesorterapp/app/thanks.html",
		"/Users/ramakay/Projects/fitnessWatcher/img/evolution.svg",
		"/Users/ramakay/Library/Application Support/Sublime Text 3/Packages/User/Jade.sublime-settings",
		"/Users/ramakay/Projects/fitnessWatcher/fw.sublime-project",
		"/Users/ramakay/Projects/fitbitoAuth2/index.js",
		"/Users/ramakay/Projects/fitnessWatcher/index2.js",
		"/Users/ramakay/Projects/fitnessWatcher/index.js",
		"/Users/ramakay/Projects/fitnessWatcher/node_modules/fitbit-client-oauth2/package.json",
		"/Users/ramakay/Downloads/Venture Capitalists_53569000889161_source/Venture Capitalists.html",
		"/Users/ramakay/Projects/timesorterapp/app/index3.html",
		"/Users/ramakay/Projects/timesorterapp/app/index.html",
		"/Users/ramakay/Projects/timesorterapp/app/index2.html",
		"/Users/ramakay/Projects/timesorterapp/app/privacy",
		"/Users/ramakay/Projects/timesorterapp/app/scss/_custom.scss",
		"/Users/ramakay/Projects/timesorterapp/README.md",
		"/Users/ramakay/Projects/timesorterapp/Gruntfile.js",
		"/Users/ramakay/Projects/timesorterapp/.jshintrc",
		"/Users/ramakay/Projects/timesorterapp/app/bower_components/imgix.js/src/url.js",
		"/Users/ramakay/Projects/timesorterapp/package.json",
		"/Users/ramakay/Projects/timesorterapp/app/scss/_appstyles.scss",
		"/Users/ramakay/Projects/timesorterapp/app/scss/_cistp,/scss.scss",
		"/Users/ramakay/Projects/timesorterapp/app/scss/_settings.scss",
		"/Users/ramakay/Projects/timesorterapp/app/scss/custom.scss",
		"/Users/ramakay/Library/Application Support/Sublime Text 3/Packages/User/Side Bar.sublime-settings",
		"/Users/ramakay/Library/Application Support/Sublime Text 3/Packages/SideBarEnhancements/Side Bar.sublime-settings",
		"/private/var/folders/jp/xvs15t4n13730_p_0ds68vsh0000gn/T/89c27a2e-503a-41eb-bcc4-a68bcca383de/index.html",
		"/private/var/folders/jp/xvs15t4n13730_p_0ds68vsh0000gn/T/1ae45ded-f463-42e6-9817-9255fe877385/rama/movingimage.html",
		"/Users/ramakay/Projects/movingimage"
	],
	"find":
	{
		"height": 79.0
	},
	"find_in_files":
	{
		"height": 173.0,
		"where_history":
		[
			"/Users/ramakay/Projects/everest-club-monaco",
			"/Users/ramakay/Projects/everest-club-monaco/clubmonaco",
			"/Users/ramakay/Projects/CM-Prototype",
			"/Users/ramakay/Projects/everest/cm-experience",
			""
		]
	},
	"find_state":
	{
		"case_sensitive": false,
		"find_history":
		[
			"template",
			"footer section",
			"something",
			"th:inline",
			"initevents",
			"login",
			"postcss",
			"dispatch",
			"checkwindow",
			"create_c",
			"create",
			"dispatch",
			"$(",
			".click",
			".on",
			"initial_re",
			"dispatch",
			"actions",
			"club",
			"DEFAULT_TEMPLATE_MODE",
			"template",
			"resolver",
			"template",
			"@header",
			".java",
			"@",
			"header",
			"ServletContextTemplateResolver",
			"templateresolver",
			"configurestore",
			"console.log",
			"console",
			"parent",
			"processNav",
			"parent",
			"fetchVCM",
			"OT_GET_CHANNEL_CONTENT",
			"OT_GET",
			"OT_GET_CHANNEL_LOAD",
			"console.",
			"fetchVCMID",
			"leaf",
			"levelArr",
			"returnValue",
			"returnval",
			"console",
			"fetchv",
			"res)",
			"Make Request",
			"nav_a",
			"make request",
			"OT_GET_CONTENT_INSTANCE",
			"makeRequest",
			"\"home\"",
			"sendResponse",
			"parentCallback",
			"levelH",
			"sendresponse",
			"res.",
			"conso",
			"catch",
			"console",
			"fetchv",
			"fetc",
			"top",
			"level",
			"makereq",
			"newTopic",
			"newT",
			"yer fav",
			"maketop",
			"maketopic",
			".dispatch",
			"folder_exclude",
			"folder_exc",
			"dispatch",
			".dispatch",
			"(dispatch)",
			"binary",
			"(dispatch)",
			" return (dispatch)",
			"function topics",
			"export function topics",
			"CREATE_TOPIC_REQUEST",
			"CREATE_TOPIC",
			"TYPING",
			"newTopic",
			"fetchcontn",
			"fetchcontent",
			"actions/content",
			"function App",
			"express",
			"app =",
			"export function App",
			"app",
			"fetchTopics",
			"content",
			"exclude",
			"content",
			"theme",
			"inline",
			"maps",
			"scene",
			"cyo",
			"node_mo",
			"exclude",
			"animation",
			"pulse",
			"res.json",
			"callback",
			"processcloses",
			"userid",
			"http",
			"the file",
			"evolution",
			"listen",
			".addClass(\"pulse\")",
			"<path",
			"age",
			"defs",
			"port",
			"='./",
			"project",
			"nonce",
			"BCEQF",
			"request",
			"timestamp",
			"res"
		],
		"highlight": true,
		"in_selection": false,
		"preserve_case": false,
		"regex": false,
		"replace_history":
		[
			"level2",
			".attr(\"class\",\"pulse\")"
		],
		"reverse": false,
		"show_context": true,
		"use_buffer2": true,
		"whole_word": false,
		"wrap": true
	},
	"groups":
	[
		{
			"selected": 1,
			"sheets":
			[
				{
					"buffer": 0,
					"file": "/Users/ramakay/Projects/everest-club-monaco/clubmonaco/fe-build/node_modules/templatebinding/TemplateBinding.js",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 92309,
						"regions":
						{
						},
						"selection":
						[
							[
								58889,
								58889
							]
						],
						"settings":
						{
							"color_helper.file_palette":
							[
							],
							"color_helper.scan":
							{
								"current_ext": ".js",
								"current_syntax": "JavaScript/JavaScript",
								"enabled": false,
								"last_updated": 1465791714.91
							},
							"syntax": "Packages/JavaScript/JavaScript.sublime-syntax",
							"tab_size": 2,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 86306.0,
						"zoom_level": 1.0
					},
					"stack_index": 1,
					"type": "text"
				},
				{
					"buffer": 1,
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 0,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"color_helper.file_palette":
							[
							],
							"color_helper.scan":
							{
								"current_ext": null,
								"current_syntax": "Text/Plain text",
								"enabled": false,
								"last_updated": 1465791714.91
							},
							"syntax": "Packages/Text/Plain text.tmLanguage"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 0,
					"type": "text"
				}
			]
		}
	],
	"incremental_find":
	{
		"height": 41.0
	},
	"input":
	{
		"height": 29.0
	},
	"layout":
	{
		"cells":
		[
			[
				0,
				0,
				1,
				1
			]
		],
		"cols":
		[
			0.0,
			1.0
		],
		"rows":
		[
			0.0,
			1.0
		]
	},
	"menu_visible": true,
	"output.exec":
	{
		"height": 228.0
	},
	"output.find_results":
	{
		"height": 0.0
	},
	"pinned_build_system": "",
	"project": "cc.sublime-project",
	"replace":
	{
		"height": 78.0
	},
	"save_all_on_build": true,
	"select_file":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
			[
				"index.js",
				"clubmonaco/fe-build/src/index.js"
			],
			[
				"index.ht",
				"clubmonaco/src/main/resources/templates/index.html"
			],
			[
				"pagef",
				"clubmonaco/fe-build/src/js/templates/pageFunctions.js"
			],
			[
				"myaccount",
				"clubmonaco/fe-build/src/js/templates/myAccount-login.js"
			],
			[
				"signin.",
				"clubmonaco/src/main/resources/templates/fragments/global/signin.html"
			],
			[
				"confg.dev",
				"clubmonaco/fe-build/webpack/config.dev.js"
			],
			[
				"myaccount-pr",
				"clubmonaco/fe-build/src/js/templates/myAccount-profile.js"
			],
			[
				"my",
				"clubmonaco/fe-build/src/js/templates/myAccount.js"
			],
			[
				"header.js",
				"clubmonaco/fe-build/src/js/fragments/header.js"
			],
			[
				"header",
				"clubmonaco/fe-build/src/js/fragments/header.js"
			],
			[
				"vie",
				"clubmonaco/fe-build/src/js/helpers/viewportHelper.js"
			],
			[
				"helpers.",
				"clubmonaco/fe-build/src/js/helpers/helpers.js"
			],
			[
				"base.js",
				"clubmonaco/fe-build/src/js/global/Base.js"
			],
			[
				"actions/ind",
				"clubmonaco/fe-build/src/js/actions/index.js"
			],
			[
				"actions/car",
				"clubmonaco/fe-build/src/js/actions/cart.js"
			],
			[
				"actions/cart",
				"clubmonaco/fe-build/src/js/actions/cart.js"
			],
			[
				"pagefunc",
				"clubmonaco/fe-build/src/js/templates/pageFunctions.js"
			],
			[
				"templates/cart",
				"clubmonaco/fe-build/src/js/templates/cart.js"
			],
			[
				"cart.js",
				"clubmonaco/fe-build/src/js/actions/cart.js"
			],
			[
				"clubmon",
				"src/main/java/com/clubmonaco/ClubmonacoApplication.java"
			],
			[
				"index",
				"fe-build/src/index.js"
			],
			[
				"cart.",
				"fe-build/src/js/actions/cart.js"
			],
			[
				"_addt",
				"src/main/resources/templates/fragments/product/add-to-cart/_add-to-cart.js"
			],
			[
				"add-",
				"src/main/resources/templates/fragments/product/add-to-cart/add-to-cart.html"
			],
			[
				"fragments/header",
				"src/main/resources/templates/fragments/header.html"
			],
			[
				"head",
				"src/main/resources/templates/head.html"
			],
			[
				"index.html",
				"src/main/resources/templates/index.html"
			],
			[
				"includ",
				"src/main/resources/templates/includes.html"
			],
			[
				"cart.html",
				"src/main/resources/templates/cart.html"
			],
			[
				"inde",
				"fe-build/index.html"
			],
			[
				"aja",
				"fe-build/src/helpers/ajax-factory.js"
			],
			[
				"in",
				"fe-build/src/index.js"
			],
			[
				"pack",
				"fe-build/package.json"
			],
			[
				"car",
				"fe-build/src/cart.js"
			],
			[
				"gridys",
				"app/components/styleguide/gridSystem.jsx"
			],
			[
				"styleg",
				"app/containers/Styleguide.jsx"
			],
			[
				"gri",
				"app/containers/Grid.jsx"
			],
			[
				"controller/channel",
				"cm-experience/server/controllers/channel.js"
			],
			[
				"server/controller/chan",
				"cm-experience/server/controllers/channel.js"
			],
			[
				"actions/nav",
				"cm-experience/app/actions/navigation.js"
			],
			[
				"controllers/ch",
				"cm-experience/server/controllers/channel.js"
			],
			[
				"server/i",
				"cm-experience/server/index.js"
			],
			[
				"navig",
				"app/actions/navigation.js"
			],
			[
				"action/users",
				"app/actions/users.js"
			],
			[
				"server/controllers.u",
				"server/controllers/users.js"
			],
			[
				"login.js",
				"app/containers/Login.jsx"
			],
			[
				"routes.jsx",
				"app/routes.jsx"
			],
			[
				"routes.js",
				"server/config/routes.js"
			],
			[
				"server/chane",
				"server/controllers/channel.js"
			],
			[
				"routes.",
				"app/routes.jsx"
			],
			[
				"routes.j",
				"app/routes.jsx"
			],
			[
				"grid",
				"app/containers/Grid.jsx"
			],
			[
				"topic",
				"app/actions/topics.js"
			],
			[
				"action/store",
				"app/actions/store.js"
			],
			[
				"reducers/store",
				"app/reducers/store.js"
			],
			[
				"store.",
				"app/actions/store.js"
			],
			[
				"app/actions/",
				"app/actions/topics.js"
			],
			[
				"readm",
				"README.md"
			],
			[
				"actions/con",
				"app/actions/content.js"
			],
			[
				"topics",
				"app/actions/topics.js"
			],
			[
				"reducers/top",
				"app/reducers/topic.js"
			],
			[
				"app/reducers",
				"app/reducers/user.js"
			],
			[
				"v",
				"app/containers/Vote.jsx"
			],
			[
				"actions/cont",
				"app/actions/content.js"
			],
			[
				"content.js",
				"server/controllers/content.js"
			],
			[
				"routes",
				"app/routes.jsx"
			],
			[
				"actions/top",
				"app/actions/topics.js"
			],
			[
				"vo",
				"app/containers/Vote.jsx"
			],
			[
				"vot",
				"app/containers/Vote.jsx"
			],
			[
				"actions/",
				"app/actions/content"
			],
			[
				"vote",
				"app/containers/Vote.jsx"
			],
			[
				"store",
				"app/store/configureStore.js"
			],
			[
				"app.jsx",
				"app/routes.jsx"
			],
			[
				"app.",
				"app/containers/App.jsx"
			],
			[
				"config/",
				"server/config/routes.js"
			],
			[
				"rea",
				"README.md"
			],
			[
				"app.ser",
				"public/assets/app.server.js"
			],
			[
				"rad",
				"README.md"
			],
			[
				"productadv",
				"web/webroot/_ui/responsive/rl-fe-build/js/pages/productDetailAdv.js"
			],
			[
				".css",
				"styles/styles.css"
			],
			[
				"ind",
				"index.js"
			],
			[
				"fitbit-node",
				"node_modules/fitbit-node/fitbit-api-client.js"
			],
			[
				"app",
				"scripts/app.js"
			],
			[
				"evo",
				"views/img/evolution.svg"
			],
			[
				"index.jade",
				"views/index.jade"
			],
			[
				".svg",
				"img/evolution.svg"
			],
			[
				"fitbit-client-ouath2/pack",
				"node_modules/fitbit-client-oauth2/package.json"
			],
			[
				"index2",
				"app/index2.html"
			],
			[
				"index3",
				"app/index3.html"
			],
			[
				"grunt",
				"Gruntfile.js"
			],
			[
				"url",
				"app/bower_components/imgix.js/src/url.js"
			],
			[
				"package",
				"package.json"
			],
			[
				"readme",
				"README.md"
			],
			[
				"grun",
				"Gruntfile.js"
			],
			[
				"_appst",
				"app/scss/_appstyles.scss"
			],
			[
				"appst",
				"app/scss/_appstyles.scss"
			],
			[
				".js",
				"app/js/app.js"
			],
			[
				"_sett",
				"app/scss/_settings.scss"
			],
			[
				"sett",
				"app/scss/_settings.scss"
			],
			[
				".scss",
				"app/scss/app.scss"
			]
		],
		"width": 0.0
	},
	"select_project":
	{
		"height": 500.0,
		"last_filter": "",
		"selected_items":
		[
			[
				"",
				"~/Projects/cm-poc/hybris-cm-poc.sublime-project"
			]
		],
		"width": 380.0
	},
	"select_symbol":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
		],
		"width": 0.0
	},
	"selected_group": 0,
	"settings":
	{
	},
	"show_minimap": false,
	"show_open_files": true,
	"show_tabs": true,
	"side_bar_visible": true,
	"side_bar_width": 448.0,
	"status_bar_visible": true,
	"template_settings":
	{
	}
}
